// SPDX-License-Identifier: AGPL-3.0
pragma solidity ^0.8.24;

import {Test} from "forge-std/Test.sol";
import {console2 as console} from "forge-std/console2.sol";
import {AddressLib} from "../src/libraries/AddressLib.sol";

contract AddressLibTest is Test {
    function test_encodeToken() public pure {
        address token = address(0xc);
        uint96 denomination = 100;
        bytes32 expected = bytes32((uint256(denomination) << 160) | uint256(uint160(token)));
        bytes32 result = AddressLib.encodeToken(token, denomination);
        assertEq(result, expected, "encodeToken should return the correct encoded value");
    }

    function test_getAddressFromBytes32() public pure {
        address token = address(0xb);
        uint96 denomination = 100;
        bytes32 encodedData = AddressLib.encodeToken(token, denomination);
        address decodedToken = AddressLib.getAddress(encodedData);
        assertEq(decodedToken, token, "getAddress should return the correct token address");
    }

    function test_getDenomination() public pure {
        address token = address(0xb);
        uint96 denomination = 100;
        bytes32 encodedData = AddressLib.encodeToken(token, denomination);
        uint256 decodedDenomination = AddressLib.getDenomination(encodedData);
        assertEq(decodedDenomination, denomination, "getDenomination should return the correct denomination");
    }

    function test_getAddressAndDenom() public pure {
        address token = address(0xa);
        uint96 denomination = 100;
        bytes32 encodedData = AddressLib.encodeToken(token, denomination);
        (address decodedToken, uint256 decodedDenomination) = AddressLib.getAddressAndDenom(encodedData);
        assertEq(decodedToken, token, "getAddressAndDenom should return the correct token address");
        assertEq(decodedDenomination, denomination, "getAddressAndDenom should return the correct denomination");
    }

    function test_encodeLoanIdToBytes32() public pure {
        address blueprint = address(0xa);
        uint32 chainId = 1;
        uint64 index = 1234;
        bytes32 expected = bytes32(AddressLib.encodeLoanId(blueprint, chainId, index));
        bytes32 result = AddressLib.encodeLoanIdToBytes32(blueprint, chainId, index);
        assertEq(result, expected, "encodeLoanIdToBytes32 should return the correct encoded value");
    }

    function test_encodeLoanId() public pure {
        address blueprint = address(0xa);
        uint32 chainId = 1;
        uint64 index = 1234;
        uint256 expected = (uint256(index) << 192) | (uint256(chainId) << 160) | uint256(uint160(blueprint));
        uint256 result = AddressLib.encodeLoanId(blueprint, chainId, index);
        assertEq(result, expected, "encodeLoanId should return the correct encoded value");
    }

    function test_getLoanAddress() public pure {
        address blueprint = address(0x2);
        uint32 chainId = 1;
        uint64 index = 1234;
        uint256 encodedData = AddressLib.encodeLoanId(blueprint, chainId, index);
        address decodedAddress = AddressLib.getAddress(encodedData);
        assertEq(decodedAddress, blueprint, "getAddress should return the correct blueprint address");
    }

    function test_decodeChainId() public pure {
        address blueprint = address(0x1);
        uint32 chainId = 1;
        uint64 index = 1234;
        uint256 encodedData = AddressLib.encodeLoanId(blueprint, chainId, index);
        uint256 decodedChainId = AddressLib.decodeChainId(encodedData);
        assertEq(decodedChainId, chainId, "decodeChainId should return the correct chain ID");
    }

    function test_decodeImplementation() public pure {
        address blueprint = address(0x1);
        uint32 chainId = 1;
        uint64 index = 1234;
        uint256 encodedData = AddressLib.encodeLoanId(blueprint, chainId, index);
        uint256 decodedIndex = AddressLib.decodeImplementation(encodedData);
        assertEq(decodedIndex, index, "decodeImplementation should return the correct index");
    }

    function test_addressToBytes32() public pure {
        address addr = address(0xfab1);
        bytes32 expected = bytes32(uint256(uint160(addr)));
        bytes32 result = AddressLib.addressToBytes32(addr);
        assertEq(result, expected, "addressToBytes32 should correctly convert address to bytes32");
    }

    function test_bytes32ToAddress() public pure {
        bytes32 b32 = bytes32(uint256(uint160(address(0xabab))));
        address expected = address(0xabab);
        address result = AddressLib.bytes32ToAddress(b32);
        assertEq(result, expected, "bytes32ToAddress should correctly convert bytes32 to address");
    }

    function test_addressToBytes32AndBack() public pure {
        address addr = address(0xfab1);
        bytes32 b32 = AddressLib.addressToBytes32(addr);
        address result = AddressLib.bytes32ToAddress(b32);
        assertEq(result, addr, "Conversion from address to bytes32 and back should result in the original address");
    }

    // test the address encoding with decimals

    function test_encodeAddressDecimalsAndFlag() public pure {
        address addr = address(0xABCD);
        uint8 decimals = 18;
        uint8 flag = 1;
        uint256 expected = (uint256(flag) << 248) | (uint256(decimals) << 160) | uint256(uint160(addr));
        uint256 result = AddressLib.encodeAddressDecimalsAndFlag(addr, decimals, flag);
        assertEq(result, expected, "encodeAddressDecimalsAndFlag should return the correct encoded value");
    }

    function test_getDecimals() public pure {
        address addr = address(0xABCD);
        uint8 decimals = 18;
        uint8 flag = 1;
        uint256 encoded = AddressLib.encodeAddressDecimalsAndFlag(addr, decimals, flag);
        uint8 decodedDecimals = AddressLib.getDecimals(encoded);
        assertEq(decodedDecimals, decimals, "getDecimals should return the correct decimal value");
    }

    function test_getFlag() public pure {
        address addr = address(0xABCD);
        uint8 decimals = 18;
        uint8 flag = 1;
        uint256 encoded = AddressLib.encodeAddressDecimalsAndFlag(addr, decimals, flag);
        uint8 decodedFlag = AddressLib.getFlag(encoded);
        assertEq(decodedFlag, flag, "getFlag should return the correct flag value");
    }

    function test_getAddressAndDecimals() public pure {
        address addr = address(0xABCD);
        uint8 decimals = 18;
        uint8 flag = 1;
        uint256 encoded = AddressLib.encodeAddressDecimalsAndFlag(addr, decimals, flag);
        (address decodedAddress, uint8 decodedDecimals) = AddressLib.getAddressAndDecimals(encoded);
        assertEq(decodedAddress, addr, "getAddressAndDecimals should return the correct address");
        assertEq(decodedDecimals, decimals, "getAddressAndDecimals should return the correct decimals");
    }
}
