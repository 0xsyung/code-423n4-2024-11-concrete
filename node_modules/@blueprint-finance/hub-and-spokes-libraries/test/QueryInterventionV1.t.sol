// SPDX-License-Identifier: AGPL-3.0
pragma solidity ^0.8.24;

import {Test} from "forge-std/Test.sol";
import {console2 as console} from "forge-std/console2.sol";
import {QueryInterventionV1} from "../src/libraries/QueryInterventionV1.sol";
import {WAD} from "../src/utils/Constants.sol";
// import {Errors} from "./Errors.sol";
import {Errors} from "../src/libraries/Errors.sol";
import {Math} from "@openzeppelin/contracts/utils/math/Math.sol";

struct AmountsInBase {
    uint256 collateralValueInBase;
    uint256 concreteCreditDebtValueInBase;
    uint256 lenderDebtValueInBase;
    uint256 foreclosureFeeInBase;
    uint256 flashloanPremiumInBase;
}

struct ThresholdInWad {
    uint256 foreclosureThresholdInWad;
    uint256 currentLtvInWad;
    uint256 lenderMaxLtvInWad;
    uint256 multiplicativeThresholdBufferInWad;
}

contract QueryInterventionV1Test is Test {
    function test_isClaimable() public pure {
        bool isProtected = true;
        uint8 numberOfClaimsUsed = 2;
        uint8 availableClaims = 5;
        uint256 currentLtvInWad = 75 * WAD / 100;
        uint256 foreclosureThresholdInWad = 74 * WAD / 100;

        bool result = QueryInterventionV1.isClaimable(
            isProtected, numberOfClaimsUsed, availableClaims, currentLtvInWad, foreclosureThresholdInWad
        );
        assertTrue(result, "isClaimable should return true");
    }

    function test_isReclaimable() public pure {
        bool expired = true;
        uint256 collateralValueInBase = 100 ether;
        uint256 concreteCreditDebtValueInBase = 40 ether;
        uint256 lenderDebtValueInBase = 40 ether;
        uint256 lenderMaxLTV = 2 * WAD / 3;

        // just about reclaimable
        bool result = QueryInterventionV1.isReclaimable(
            expired, collateralValueInBase, concreteCreditDebtValueInBase, lenderDebtValueInBase, lenderMaxLTV
        );
        assertTrue(result, "isReclaimable should return true");

        // not reclaimable
        lenderMaxLTV -= 1;
        result = QueryInterventionV1.isReclaimable(
            expired, collateralValueInBase, concreteCreditDebtValueInBase, lenderDebtValueInBase, lenderMaxLTV
        );
        assertTrue(!result, "isReclaimable should return false");

        // not expire yet
        expired = false;
        result = QueryInterventionV1.isReclaimable(
            expired, collateralValueInBase, concreteCreditDebtValueInBase, lenderDebtValueInBase, lenderMaxLTV
        );
        assertTrue(!result, "isReclaimable should return false, because the policy has not expired yet");
    }

    function test_isForeclosableType2_shouldReturnTheRightForeclosableFlag() public pure {
        // case 1: foreclosable type 2 should be true
        uint8 numberOfClaimsUsed = 5;
        uint8 availableClaims = 5;
        bool expired = false;
        ThresholdInWad memory thresholdsInWad;
        thresholdsInWad.foreclosureThresholdInWad = 74 * WAD / 100;
        thresholdsInWad.currentLtvInWad = 75 * WAD / 100;

        bool foreclosable = QueryInterventionV1._isForeclosableType2(
            expired,
            numberOfClaimsUsed,
            availableClaims,
            thresholdsInWad.foreclosureThresholdInWad,
            thresholdsInWad.currentLtvInWad
        );
        assertTrue(foreclosable, "foreclosable of type 2 should be true, because all the conditions are met");

        // case 2: not foreclosable type 2 because not used all claims
        numberOfClaimsUsed -= 1;
        availableClaims = 5;
        thresholdsInWad.foreclosureThresholdInWad = 74 * WAD / 100;
        thresholdsInWad.currentLtvInWad = 75 * WAD / 100;

        foreclosable = QueryInterventionV1._isForeclosableType2(
            expired,
            numberOfClaimsUsed,
            availableClaims,
            thresholdsInWad.foreclosureThresholdInWad,
            thresholdsInWad.currentLtvInWad
        );

        assertTrue(!foreclosable, "foreclosable of type 2 should be false, because not used all claims");

        // case 3: should not be foreclosable type 2 because currentLtvInWad < foreclosureThresholdInWad

        numberOfClaimsUsed += 1;
        availableClaims = 5;

        thresholdsInWad.foreclosureThresholdInWad = 74 * WAD / 100;
        thresholdsInWad.currentLtvInWad = 73 * WAD / 100;

        foreclosable = QueryInterventionV1._isForeclosableType2(
            expired,
            numberOfClaimsUsed,
            availableClaims,
            thresholdsInWad.foreclosureThresholdInWad,
            thresholdsInWad.currentLtvInWad
        );

        assertTrue(
            !foreclosable, "foreclosable of type 2 should be false, because currentLtvInWad < foreclosureThresholdInWad"
        );

        // case 4: should not be foreclosable type 2 because it has already expired.

        numberOfClaimsUsed = 5;
        availableClaims = 5;
        expired = true;

        thresholdsInWad.foreclosureThresholdInWad = 74 * WAD / 100;
        thresholdsInWad.currentLtvInWad = 75 * WAD / 100;

        foreclosable = QueryInterventionV1._isForeclosableType2(
            expired,
            numberOfClaimsUsed,
            availableClaims,
            thresholdsInWad.foreclosureThresholdInWad,
            thresholdsInWad.currentLtvInWad
        );

        assertTrue(!foreclosable, "foreclosable of type 2 should be false, because it has already expired.");
    }

    function test_isForeclosableType3_shouldReturnTheRightForeclosableFlag() public pure {
        // case 1: foreclosable type 3 should be true
        bool expired = true;
        uint256 collateralValueInBase = 100 ether;
        uint256 concreteCreditDebtValueInBase = 40 ether;
        uint256 lenderDebtValueInBase = 40 ether;
        uint256 lenderMaxLTV = (2 * WAD / 3) - 1;

        bool foreclosable = QueryInterventionV1._isForeclosableType3(
            expired, collateralValueInBase, concreteCreditDebtValueInBase, lenderDebtValueInBase, lenderMaxLTV
        );
        assertTrue(foreclosable, "foreclosable of type 3 should be true, because all the conditions are met");

        // case 2: not foreclosable type 3 because debt can be withdrawn
        lenderMaxLTV += 1;
        foreclosable = QueryInterventionV1._isForeclosableType3(
            expired, collateralValueInBase, concreteCreditDebtValueInBase, lenderDebtValueInBase, lenderMaxLTV
        );
        assertTrue(!foreclosable, "foreclosable of type 3 should be false, because debt can be withdrawn");

        // case 3: should not be foreclosable type 3 because it has not expired yet.

        expired = false;

        foreclosable = QueryInterventionV1._isForeclosableType3(
            expired, collateralValueInBase, concreteCreditDebtValueInBase, lenderDebtValueInBase, lenderMaxLTV
        );

        assertTrue(!foreclosable, "foreclosable of type 3 should be false, because it has not expired yet.");
    }

    function test_isForeclosableType4_shouldReturnTheRightForeclosableFlag() public pure {
        // case 1: foreclosable type 4 should be true
        bool expired = false;
        uint256 collateralValueInBase = 100 ether;
        uint256 concreteCreditDebtValueInBase = 40 ether;
        uint256 lenderDebtValueInBase = 40 ether;
        uint256 foreclosureFeeInBase = 5 ether;
        uint256 flashloanPremiumInBase = 5 ether;
        uint256 multiplicativeThresholdBufferInWad = (20 * WAD / 100) + 1;

        bool foreclosable = QueryInterventionV1._isForeclosableType4(
            expired,
            collateralValueInBase,
            concreteCreditDebtValueInBase,
            lenderDebtValueInBase,
            foreclosureFeeInBase,
            flashloanPremiumInBase,
            multiplicativeThresholdBufferInWad
        );
        assertTrue(foreclosable, "foreclosable of type 4 should be true, because all the conditions are met");

        // case 2: not foreclosable type 4 because debt is not close to reclaimable.
        lenderDebtValueInBase -= 1 ether;

        foreclosable = QueryInterventionV1._isForeclosableType4(
            expired,
            collateralValueInBase,
            concreteCreditDebtValueInBase,
            lenderDebtValueInBase,
            foreclosureFeeInBase,
            flashloanPremiumInBase,
            multiplicativeThresholdBufferInWad
        );

        assertTrue(
            !foreclosable, "foreclosable of type 4 should be false, because debt is not close to reclaimable limit"
        );

        // case 3: not foreclosable type 4 because buffer is too low

        lenderDebtValueInBase += 1 ether;
        multiplicativeThresholdBufferInWad -= 1;

        foreclosable = QueryInterventionV1._isForeclosableType4(
            expired,
            collateralValueInBase,
            concreteCreditDebtValueInBase,
            lenderDebtValueInBase,
            foreclosureFeeInBase,
            flashloanPremiumInBase,
            multiplicativeThresholdBufferInWad
        );

        assertTrue(!foreclosable, "foreclosable of type 4 should be false, because buffer is too low");

        // case 4: should not be foreclosable type 4 because it has already expired.

        expired = true;

        foreclosable = QueryInterventionV1._isForeclosableType4(
            expired,
            collateralValueInBase,
            concreteCreditDebtValueInBase,
            lenderDebtValueInBase,
            foreclosureFeeInBase,
            flashloanPremiumInBase,
            multiplicativeThresholdBufferInWad
        );

        assertTrue(!foreclosable, "foreclosable of type 4 should be false, because it has already expired.");

        // // case 2: not foreclosable type 4 because debt is not close to reclaimable limit
        // lenderDebtValueInBase = 50 ether;
        // foreclosable = QueryInterventionV1._isForeclosableType4(
        //     expirationDate,
        //     blockTimestamp,
        //     collateralValueInBase,
        //     concreteCreditDebtValueInBase,
        //     lenderDebtValueInBase,
        //     foreclosureFeeInBase,
        //     flashloanPremiumInBase,
        //     multiplicativeThresholdBufferInWad
        // );
        // assertTrue(!foreclosable, "foreclosable of type 4 should be false, because debt is not close to reclaimable limit");

        // // case 3: should not be foreclosable type 4 because it has not expired yet.

        // expirationDate += 1 days;

        // foreclosable = QueryInterventionV1._isForeclosableType4(
        //     expirationDate,
        //     blockTimestamp,
        //     collateralValueInBase,
        //     concreteCreditDebtValueInBase,
        //     lenderDebtValueInBase,
        //     foreclosureFeeInBase,
        //     flashloanPremiumInBase,
        //     multiplicativeThresholdBufferInWad
        // );

        // assertTrue
    }

    function test_isLiteForeclosable() public pure {
        uint256 currentLtvInWad = 75 * WAD / 100;
        uint256 liteForeclosureThresholdInWad = 74 * WAD / 100;

        uint8 result = QueryInterventionV1.isLiteForeclosable(currentLtvInWad, liteForeclosureThresholdInWad);
        assertEq(result, 1, "isLiteForeclosable should return 1");
    }
}
