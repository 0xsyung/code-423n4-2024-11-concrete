// SPDX-License-Identifier: AGPL-3.0
pragma solidity 0.8.24;

import {Test} from "forge-std/Test.sol";
import {console2 as console} from "forge-std/console2.sol";
import {Math} from "@openzeppelin/contracts/utils/math/Math.sol";
import {Initializable} from "@openzeppelin/contracts/proxy/utils/Initializable.sol";
import {ProtectionViewLibV1} from "../src/libraries/ProtectionViewLibV1.sol";

import {Errors} from "../src/libraries/Errors.sol";
import {CreditInfoV1} from "../src/libraries/CreditInfoV1.sol";
import {ProtectionType, AmountType, ProtectionData} from "../src/utils/DataTypes.sol";
import {ProtectionLibV1} from "../src/libraries/ProtectionLibV1.sol";

// depends that the RemoteRegistry is tested and the Mock is implemented properly.
contract TestProtectionViewLib is Test {
    using Math for uint256;
    using ProtectionViewLibV1 for *;
    using CreditInfoV1 for uint256;
    using ProtectionLibV1 for uint256;

    // Constants for easier readability
    uint256 constant WAD = 1e18;
    uint256 constant PRICE_FEED_QUOTE_DENOMINATION = 1e8;
    uint256 constant FEE_AMOUNT_WIGGLE_FACTOR_IN_WAD = 1e16;
    uint256 constant lenderLiqLtvInWad = 90 * 1e16;

    struct BorrowParams {
        uint256 criticalLtvInWad;
        uint256 currentLtv;
        uint256 currentSupplyInCollateral;
        uint256 borrowAmountInTokens;
        uint256 priceOfCollateralInBorrow;
        uint256 priceQuoteDenomination;
    }

    struct WithdrawParams {
        uint256 criticalLtvInWad;
        uint256 currentLtv;
        uint256 currentDebtInBorrowTokens;
        uint256 withdrawAmountInTokens;
        uint256 priceOfCollateralInBorrow;
        uint256 priceQuoteDenomination;
    }

    WithdrawParams defaultParams;
    BorrowParams defaultBorrowParams;

    function setUp() public {
        // FIXME: I changed everything to priceQuoteDenomination, so the function signature of surpassCriticalLtvAfterWithdraw should was updated.
        defaultParams = WithdrawParams({
            criticalLtvInWad: 80 * 1e16, // 80%
            currentLtv: 70 * 1e16, // 70%
            currentDebtInBorrowTokens: 100 * 1e18,
            withdrawAmountInTokens: 5 * 1e18,
            priceOfCollateralInBorrow: 2 * 1e8,
            priceQuoteDenomination: 1e36
        });
        //FIXME: I changed everything to priceQuoteDenomination, so the function signature of surpassCriticalLtvAfterBorrow was updated.
        defaultBorrowParams = BorrowParams({
            criticalLtvInWad: 80 * 1e16, // 80%
            currentLtv: 70 * 1e16, // 70%
            currentSupplyInCollateral: 100 * 1e18,
            borrowAmountInTokens: 10 * 1e18,
            priceOfCollateralInBorrow: 2 * 1e8,
            priceQuoteDenomination: 1e36
        });
    }

    function test_getProtectionType_unprotected_shouldPass() public view {
        uint256 protectionInfo = 0;
        uint256 concreteLiteInfo = 0;
        uint256 creditInfo = 0;

        ProtectionType protectionType =
            ProtectionViewLibV1.getProtectionType(protectionInfo, concreteLiteInfo, creditInfo);
        assertEq(uint256(protectionType), uint256(ProtectionType.Unprotected));
        assertEq(
            ProtectionViewLibV1.getCurrentInterventionLtv(
                protectionInfo, concreteLiteInfo, creditInfo, lenderLiqLtvInWad
            ),
            type(uint256).max
        );
    }

    function test_getProtectionType_liteProtected_shouldPass() public view {
        uint256 protectionInfo = 0;
        uint256 concreteLiteInfo = ProtectionLibV1.updateConcreteLiteEnabled(0, true);
        uint256 creditInfo = 0;

        ProtectionType protectionType =
            ProtectionViewLibV1.getProtectionType(protectionInfo, concreteLiteInfo, creditInfo);
        assertEq(uint256(protectionType), uint256(ProtectionType.LiteProtected));

        // update the concrete lite info to 1 to see if the protection type changes
        concreteLiteInfo = ProtectionLibV1.updateLtvProtectForForeclosure(concreteLiteInfo, 10 * 1e16); // 10%
        // 90% - 10%/90% = 81%
        assertEq(
            ProtectionViewLibV1.getCurrentInterventionLtv(
                protectionInfo, concreteLiteInfo, creditInfo, lenderLiqLtvInWad
            ),
            81 * 1e16
        );
    }

    function test_getProtectionType_fullProtected_shouldPass() public view {
        ProtectionData memory protectionData = getDefaultProtectionData(block.timestamp + 1 days);
        uint256 protectionInfo = ProtectionLibV1.encodeProtectionData(protectionData);
        uint256 concreteLiteInfo = 0;
        uint256 creditInfo = 0;

        ProtectionType protectionType =
            ProtectionViewLibV1.getProtectionType(protectionInfo, concreteLiteInfo, creditInfo);
        assertEq(uint256(protectionType), uint256(ProtectionType.FullProtected));

        // 90% - 7.5%/90% = 83.25%
        assertEq(
            ProtectionViewLibV1.getCurrentInterventionLtv(
                protectionInfo, concreteLiteInfo, creditInfo, lenderLiqLtvInWad
            ),
            83.25 * 1e16
        );
    }

    function test_getProtectionType_expiredWithDebt_shouldPass() public {
        ProtectionData memory protectionData = getDefaultProtectionData(block.timestamp);
        uint256 protectionInfo = ProtectionLibV1.encodeProtectionData(protectionData);
        vm.warp(block.timestamp + 1 days);
        uint256 concreteLiteInfo = 0;
        uint256 creditInfo = CreditInfoV1.updateCredit(type(uint256).max, 1 ether, 2 ether);

        ProtectionType protectionType =
            ProtectionViewLibV1.getProtectionType(protectionInfo, concreteLiteInfo, creditInfo);
        assertEq(uint256(protectionType), uint256(ProtectionType.ExpiredWithDebt));
        // 90% - 7.5%/90% = 83.25%
        assertEq(
            ProtectionViewLibV1.getCurrentInterventionLtv(
                protectionInfo, concreteLiteInfo, creditInfo, lenderLiqLtvInWad
            ),
            83.25 * 1e16
        );
    }

    function test_getProtectionType_expiredWithoutDebtWithoutLite_shouldPass() public {
        ProtectionData memory protectionData = getDefaultProtectionData(block.timestamp);
        vm.warp(block.timestamp + 1 days);
        uint256 protectionInfo = ProtectionLibV1.encodeProtectionData(protectionData);
        uint256 concreteLiteInfo = 0;
        uint256 creditInfo = CreditInfoV1.updateCredit(type(uint256).max, 0, 0);

        ProtectionType protectionType =
            ProtectionViewLibV1.getProtectionType(protectionInfo, concreteLiteInfo, creditInfo);
        assertEq(uint256(protectionType), uint256(ProtectionType.ExpiredWithoutDebtWithoutLite));
        assertEq(
            ProtectionViewLibV1.getCurrentInterventionLtv(
                protectionInfo, concreteLiteInfo, creditInfo, lenderLiqLtvInWad
            ),
            type(uint256).max
        );
    }

    function test_getProtectionType_expiredWithoutDebtWithLite_shouldPass() public {
        ProtectionData memory protectionData = getDefaultProtectionData(block.timestamp);
        vm.warp(block.timestamp + 1 days);
        uint256 protectionInfo = ProtectionLibV1.encodeProtectionData(protectionData);
        uint256 concreteLiteInfo = ProtectionLibV1.updateConcreteLiteEnabled(0, true);
        uint256 creditInfo = CreditInfoV1.updateCredit(type(uint256).max, 0, 0);

        ProtectionType protectionType =
            ProtectionViewLibV1.getProtectionType(protectionInfo, concreteLiteInfo, creditInfo);
        assertEq(uint256(protectionType), uint256(ProtectionType.ExpiredWithoutDebtWithLite));
        concreteLiteInfo = ProtectionLibV1.updateLtvProtectForForeclosure(concreteLiteInfo, 10 * 1e16); // 10%
        assertEq(
            ProtectionViewLibV1.getCurrentInterventionLtv(
                protectionInfo, concreteLiteInfo, creditInfo, lenderLiqLtvInWad
            ),
            81 * 1e16
        );
    }

    // function test_surpassCriticalLtvAfterBorrow_shouldPass() public view {
    //     // Test case 1: LTV surpasses critical after borrow
    //     BorrowParams memory params = defaultBorrowParams;
    //     params.borrowAmountInTokens = 25e18;
    //     // 70% + 25/200 = 82.5%
    //     assertTrue(runSurpassCheck(params));

    //     // Test case 2: LTV does not surpass critical after borrow
    //     params = defaultBorrowParams;
    //     params.borrowAmountInTokens = 10e18;
    //     // 70% + 10/200 = 75%
    //     assertFalse(runSurpassCheck(params));

    //     // Test case 3: Edge case - LTV exactly at critical after borrow
    //     params = defaultBorrowParams;
    //     params.borrowAmountInTokens = 20e18;
    //     assertFalse(runSurpassCheck(params));

    //     // Test case 4: Different price and denominations
    //     params = defaultBorrowParams;
    //     params.borrowAmountInTokens = 25000e6; // USDC amount
    //     params.priceOfCollateralInBorrow = 2000e8; // ETH/USDC price
    //     params.priceQuoteDenomination = 1e36; // Price Quote Denom
    //     assertTrue(runSurpassCheck(params));

    //     // Test case 5: Zero borrow amount
    //     params = defaultBorrowParams;
    //     params.borrowAmountInTokens = 0; // Zero borrow amount
    //     assertFalse(runSurpassCheck(params));
    // }

    // function test_surpassCriticalLtvAfterWithdraw_shouldPass() public view {
    //     // Test case 1: Withdrawal does not surpass critical LTV
    //     (bool surpassed, uint256 newLtv) = calculateLtvAfterWithdraw(defaultParams);
    //     assertLt(newLtv, defaultParams.criticalLtvInWad);
    //     assertEq(runTestCriticalLtvAfterWithdraw(defaultParams), surpassed);

    //     // Test case 2: Withdrawal surpasses critical LTV
    //     WithdrawParams memory params = defaultParams;
    //     params.currentLtv = 75 * 1e16; // 75%
    //     params.withdrawAmountInTokens = 10 * 1e18;
    //     (surpassed, newLtv) = calculateLtvAfterWithdraw(params);
    //     assertGt(newLtv, params.criticalLtvInWad);
    //     assertEq(runTestCriticalLtvAfterWithdraw(params), surpassed);

    //     // Test case 3: Edge case - current LTV very close to critical LTV
    //     params = defaultParams;
    //     params.currentLtv = 79.9 * 1e16; // 79.9%
    //     params.withdrawAmountInTokens = 100 * 1e18;
    //     assertTrue(runTestCriticalLtvAfterWithdraw(params));
    //     (surpassed, newLtv) = calculateLtvAfterWithdraw(params);
    //     assertGt(newLtv, params.criticalLtvInWad);
    //     assertEq(runTestCriticalLtvAfterWithdraw(params), surpassed);

    //     // Test case 4: Very small withdrawal, should not surpass
    //     params = defaultParams;
    //     params.withdrawAmountInTokens = 0.0001 * 1e18;
    //     (surpassed, newLtv) = calculateLtvAfterWithdraw(params);
    //     assertLt(newLtv, params.criticalLtvInWad);
    //     assertEq(runTestCriticalLtvAfterWithdraw(params), surpassed);
    // }

    function getDefaultProtectionData(uint256 expiryTime) public pure returns (ProtectionData memory) {
        uint32[] memory trancheAmountFractionInMillionth = new uint32[](3);
        uint32[] memory trancheFeeRateInMillionth = new uint32[](3);
        trancheAmountFractionInMillionth[0] = 300000;
        trancheAmountFractionInMillionth[1] = 300000;
        trancheAmountFractionInMillionth[2] = 400000;
        trancheFeeRateInMillionth[0] = 3000;
        trancheFeeRateInMillionth[1] = 3000;
        trancheFeeRateInMillionth[2] = 4000;

        return ProtectionData({
            endTime: uint40(expiryTime),
            numberOfTranches: 3,
            rightsEncoding: 1,
            ltvProtectClaims: 7500,
            ltvProtectForeclosure: 75000,
            openingFeeRate: 6000,
            cancellationFeeRate: 6000,
            trancheAmountFractionInMillionth: trancheAmountFractionInMillionth,
            trancheFeeRateInMillionth: trancheFeeRateInMillionth
        });
    }

    function runSurpassCheck(BorrowParams memory params) internal pure returns (bool) {
        return ProtectionViewLibV1.surpassCriticalLtvAfterBorrow(
            params.criticalLtvInWad,
            params.currentLtv,
            params.currentSupplyInCollateral,
            params.borrowAmountInTokens,
            params.priceOfCollateralInBorrow,
            params.priceQuoteDenomination
        );
    }

    function runTestCriticalLtvAfterWithdraw(WithdrawParams memory params) internal pure returns (bool) {
        return ProtectionViewLibV1.surpassCriticalLtvAfterWithdraw(
            params.criticalLtvInWad,
            params.currentLtv,
            params.currentDebtInBorrowTokens,
            params.withdrawAmountInTokens,
            params.priceOfCollateralInBorrow,
            params.priceQuoteDenomination
        );
    }

    function calculateLtvAfterWithdraw(WithdrawParams memory params)
        internal
        pure
        returns (bool surpassed, uint256 newLtv)
    {
        uint256 currentCollateralValueInBorrowTokens = (params.currentDebtInBorrowTokens * WAD) / params.currentLtv;
        // FIXME: I changed everything to priceQuoteDenomination. Please check if its correct. Probably not. Needs refactor.
        uint256 withdrawValueInBorrowTokens = (params.withdrawAmountInTokens * params.priceOfCollateralInBorrow)
            / (params.priceQuoteDenomination * PRICE_FEED_QUOTE_DENOMINATION);

        if (withdrawValueInBorrowTokens >= currentCollateralValueInBorrowTokens) {
            return (true, type(uint256).max);
        }

        uint256 newCollateralValue = currentCollateralValueInBorrowTokens - withdrawValueInBorrowTokens;
        newLtv = (params.currentDebtInBorrowTokens * WAD) / newCollateralValue;
        surpassed = newLtv > params.criticalLtvInWad;
        return (surpassed, newLtv);
    }

    function test_checkForeclosureFeeAmount_ShouldPass() public pure {
        uint256 providedFeeFractionInWad = 500 * WAD / 10000;
        uint256 feeFractionInWad = 499 * WAD / 10000;
        ProtectionViewLibV1.checkForeclosureFeeAmount(
            providedFeeFractionInWad, feeFractionInWad, FEE_AMOUNT_WIGGLE_FACTOR_IN_WAD
        );
    }

    function testfail_checkForeclosureFeeAmount_ShouldFail() public {
        uint256 providedFeeFractionInWad = 500 * WAD / 10000;
        uint256 feeFractionInWad = 400 * WAD / 10000;
        // vm expect revert
        vm.expectRevert(
            abi.encodeWithSelector(
                Errors.AmountDiviatesTooMuch.selector,
                providedFeeFractionInWad,
                feeFractionInWad,
                FEE_AMOUNT_WIGGLE_FACTOR_IN_WAD
            )
        );
        ProtectionViewLibV1.checkForeclosureFeeAmount(
            providedFeeFractionInWad, feeFractionInWad, FEE_AMOUNT_WIGGLE_FACTOR_IN_WAD
        );
    }

    // function test_checkAmountsFromInfo_ShouldPass() public view {
    //     uint256 supplyAmount = 1000 ether;
    //     uint256 borrowAmount = 1_500_000 * 10 ** 6;
    //     // (uint256 supplyAmountInBase, uint256 borrowAmountInBase) =
    //     //     _getCollatAndBorrowBasePrices(supplyAmount, borrowAmount, collateralAsset, borrowAsset);

    //     (uint256 info, uint256 promisedAmountInCollateral) =
    //         _createConcreteProtectionEncoding(supplyAmount, borrowAmount);
    //     uint256 expectedAmount = info.getCancellationFeeFractionInWad().mulDiv(promisedAmountInCollateral, WAD);
    //     uint256 goodAmount = expectedAmount.mulDiv(WAD + FEE_AMOUNT_WIGGLE_FACTOR_IN_WAD, WAD) - 1;
    //     ProtectionViewLibV1.checkAmountsFromInfo(
    //         goodAmount,
    //         info,
    //         promisedAmountInCollateral,
    //         AmountType.CancelProtectionFeeAmount,
    //         FEE_AMOUNT_WIGGLE_FACTOR_IN_WAD
    //     );
    // }

    // function testfail_checkAmountsFromInfo_ShouldRevert() public {
    //     uint256 supplyAmount = 1000 ether;
    //     uint256 borrowAmount = 1_500_000 * 10 ** 6;
    //     // (uint256 supplyAmountInBase, uint256 borrowAmountInBase) =
    //     //     _getCollatAndBorrowBasePrices(supplyAmount, borrowAmount, collateralAsset, borrowAsset);

    //     (uint256 info, uint256 promisedAmountInCollateral) =
    //         _createConcreteProtectionEncoding(supplyAmount, borrowAmount);
    //     uint256 expectedAmount = info.getCancellationFeeFractionInWad().mulDiv(promisedAmountInCollateral, WAD);
    //     uint256 badAmount = expectedAmount.mulDiv(WAD + FEE_AMOUNT_WIGGLE_FACTOR_IN_WAD, WAD) + 1;
    //     // vm expect revert
    //     vm.expectRevert(
    //         abi.encodeWithSelector(
    //             Errors.AmountDiviatesTooMuch.selector, badAmount, expectedAmount, FEE_AMOUNT_WIGGLE_FACTOR_IN_WAD
    //         )
    //     );
    //     ProtectionViewLibV1.checkAmountsFromInfo(
    //         badAmount,
    //         info,
    //         promisedAmountInCollateral,
    //         AmountType.CancelProtectionFeeAmount,
    //         FEE_AMOUNT_WIGGLE_FACTOR_IN_WAD
    //     );
    // }
}
