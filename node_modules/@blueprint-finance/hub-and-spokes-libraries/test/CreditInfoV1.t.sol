// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.24;

import {Test} from "forge-std/Test.sol";
import {console2 as console} from "forge-std/console2.sol";
import {WAD} from "../src/utils/Constants.sol";
// import {Counter} from "../src/Counter.sol";
import {CreditInfoV1} from "../src/libraries/CreditInfoV1.sol";

contract CreditInfoV1Test is Test {
    function test_updateCredit_shouldUpdateCredit() public pure {
        uint256 originalValue = type(uint256).max;
        uint256 amountInBase = 1 ether;
        uint256 amountInToken = 2 ether;
        uint256 updatedValue = CreditInfoV1.updateCredit(originalValue, amountInBase, amountInToken);
        // the first 112 bits should be filled with 1s
        assertEq(uint112(bytes14(bytes32(updatedValue))), type(uint112).max, "first 112 bits should be filled with 1s");
        // the next 144 bits should not be filled with only 1s
        assertNotEq(uint144(updatedValue), type(uint144).max, "next 144 bits should not be filled with only 1s");
        // get the amountInBase and amountInToken from the updatedValue
        (uint256 updatedAmountInBase, uint256 updatedAmountInToken) = CreditInfoV1.decodeCreditAmount(updatedValue);
        assertEq(updatedAmountInBase, amountInBase, "amountInBase should be equal to the updated amountInBase");
        assertEq(updatedAmountInToken, amountInToken, "amountInToken should be equal to the updated amountInToken");
    }

    function test_updateBorrowFraction() public pure {
        uint256 originalValue = type(uint256).max;
        uint256 newValue = 5 * WAD / 10000; // = 0.0005
        uint256 updatedValue = CreditInfoV1.updateUserBorrowFraction(originalValue, newValue);
        // the first 112 bits should be filled with 1s
        assertEq(uint144(updatedValue), type(uint144).max, "last 144 bits should be filled with 1s");
        // get the userBorrowFraction from the updatedValue
        uint256 updatedUserBorrowFraction = CreditInfoV1.decodeUserBorrowFraction(updatedValue);
        // assert approximately equal updatedUserBorrowFraction and newValue
        assertApproxEqRel(
            updatedUserBorrowFraction,
            newValue,
            WAD / 10 ** 14,
            "userBorrowFraction should be approximately equal to the updated userBorrowFraction"
        );
    }

    function test_updateSupplyFraction() public pure {
        uint256 originalValue = type(uint256).max;
        uint256 newValue = 5 * WAD / 10000; // = 0.0005
        uint256 updatedValue = CreditInfoV1.updateUserSupplyFraction(originalValue, newValue);
        // the first 112 bits should be filled with 1s
        assertEq(uint144(updatedValue), type(uint144).max, "last 144 bits should be filled with 1s");
        // get the userSupplxFraction from the updatedValue
        uint256 updatedUserSupplyFraction = CreditInfoV1.decodeUserSupplyFraction(updatedValue);
        assertEq(
            updatedUserSupplyFraction, newValue, "userSupplxFraction should be equal to the updated userSupplxFraction"
        );
    }

    function test_computeNewUserBorrowFractionInWad() public pure {
        uint256 oldUserBorrowFractionInWad = WAD / 2; // = 0.5 =  50%
        uint256 totalBorrowedInToken = 2 ether;
        uint256 amountInToken = 1 ether;
        // scenario is user repays
        bool isRepayment = true;
        bool byUser = true;
        uint256 expectedInWad = 0 * WAD;
        uint256 newUserBorrowFractionInWad = CreditInfoV1.computeNewUserBorrowFractionInWad(
            oldUserBorrowFractionInWad, totalBorrowedInToken, amountInToken, isRepayment, byUser
        );
        assertApproxEqRel(
            newUserBorrowFractionInWad,
            expectedInWad,
            WAD / 10 ** 14,
            "newUserBorrowFractionInWad should be equal to 0 WAD upon repayment by user"
        );
        // scenario is user borrows
        isRepayment = false;
        byUser = true;
        expectedInWad = 2 * WAD / 3;
        newUserBorrowFractionInWad = CreditInfoV1.computeNewUserBorrowFractionInWad(
            oldUserBorrowFractionInWad, totalBorrowedInToken, amountInToken, isRepayment, byUser
        );
        assertApproxEqRel(
            newUserBorrowFractionInWad,
            expectedInWad,
            WAD / 10 ** 14,
            "newUserBorrowFractionInWad should be equal to 2/3 WAD upon borrowing by user"
        );
        // scenario is concrete repays
        isRepayment = true;
        byUser = false;
        expectedInWad = WAD;
        newUserBorrowFractionInWad = CreditInfoV1.computeNewUserBorrowFractionInWad(
            oldUserBorrowFractionInWad, totalBorrowedInToken, amountInToken, isRepayment, byUser
        );
        assertApproxEqRel(
            newUserBorrowFractionInWad,
            expectedInWad,
            WAD / 10 ** 14,
            "newUserBorrowFractionInWad should be equal to 1 WAD upon repayment by concrete"
        );
        // scenario is concrete borrows
        isRepayment = false;
        byUser = false;
        expectedInWad = 1 * WAD / 3;
        newUserBorrowFractionInWad = CreditInfoV1.computeNewUserBorrowFractionInWad(
            oldUserBorrowFractionInWad, totalBorrowedInToken, amountInToken, isRepayment, byUser
        );
        assertApproxEqRel(
            newUserBorrowFractionInWad,
            expectedInWad,
            WAD / 10 ** 14,
            "newUserBorrowFractionInWad should be equal to 1/3 WAD upon borrowing by concrete"
        );
    }

    function test_computeNewUserSupplyFractionInWad() public pure {
        uint256 oldUserSupplyFractionInWad = WAD / 2; // = 0.5 =  50%
        uint256 totalSuppliedInToken = 2 ether;
        uint256 amountInToken = 1 ether;
        // scenario is user withdraws
        bool isWithdrawal = true;
        bool byUser = true;
        uint256 expectedInWad = 0 * WAD;
        uint256 newUserSupplyFractionInWad = CreditInfoV1.computeNewUserSupplyFractionInWad(
            oldUserSupplyFractionInWad, totalSuppliedInToken, amountInToken, isWithdrawal, byUser
        );
        assertApproxEqRel(
            newUserSupplyFractionInWad,
            expectedInWad,
            WAD / 10 ** 14,
            "newUserSupplyFractionInWad should be equal to 0 WAD upon withdrawal by user"
        );
        // scenario is user supplies
        isWithdrawal = false;
        byUser = true;
        expectedInWad = 2 * WAD / 3;
        newUserSupplyFractionInWad = CreditInfoV1.computeNewUserSupplyFractionInWad(
            oldUserSupplyFractionInWad, totalSuppliedInToken, amountInToken, isWithdrawal, byUser
        );
        assertApproxEqRel(
            newUserSupplyFractionInWad,
            expectedInWad,
            WAD / 10 ** 14,
            "newUserSupplyFractionInWad should be equal to 2/3 WAD upon supply by user"
        );
        // scenario is concrete withdraws
        isWithdrawal = true;
        byUser = false;
        expectedInWad = WAD;
        newUserSupplyFractionInWad = CreditInfoV1.computeNewUserSupplyFractionInWad(
            oldUserSupplyFractionInWad, totalSuppliedInToken, amountInToken, isWithdrawal, byUser
        );
        assertApproxEqRel(
            newUserSupplyFractionInWad,
            expectedInWad,
            WAD / 10 ** 14,
            "newUserSupplyFractionInWad should be equal to 1 WAD upon withdrawal by concrete"
        );
        // scenario is concrete supplies
        isWithdrawal = false;
        byUser = false;
        expectedInWad = 1 * WAD / 3;
        newUserSupplyFractionInWad = CreditInfoV1.computeNewUserSupplyFractionInWad(
            oldUserSupplyFractionInWad, totalSuppliedInToken, amountInToken, isWithdrawal, byUser
        );
        assertApproxEqRel(
            newUserSupplyFractionInWad,
            expectedInWad,
            WAD / 10 ** 14,
            "newUserSupplyFractionInWad should be equal to 1/3 WAD upon supply by concrete"
        );
    }
}
// contract CounterTest is Test {
//     Counter internal counter;

//     function setUp() internal {
//         counter = new Counter();
//         counter.setNumber(0);
//     }

//     function test_Increment() internal {
//         counter.increment();
//         assertEq(counter.number(), 1);
//     }

//     function testFuzz_SetNumber(uint256 x) internal {
//         counter.setNumber(x);
//         assertEq(counter.number(), x);
//     }
// }
