// SPDX-License-Identifier: AGPL-3.0
pragma solidity ^0.8.24;

import {Test} from "forge-std/Test.sol";
import {console2 as console} from "forge-std/console2.sol";
import {CompactEncodeLib} from "../src/libraries/CompactEncodeLib.sol";

contract CompactEncodeLibTest is Test {
    function test_encode_uint8() public pure {
        uint256 number = 1000;
        (uint8 significand, uint8 exponent) = CompactEncodeLib.encode_uint8(number);
        uint256 decodedNumber = CompactEncodeLib.decode_uint8(significand, exponent);
        assertEq(decodedNumber, number, "encode_uint8 should correctly encode and decode the number");
    }

    function test_encode_uint16() public pure {
        uint256 number = 70000;
        (uint16 significand, uint8 exponent) = CompactEncodeLib.encode_uint16(number);
        uint256 decodedNumber = CompactEncodeLib.decode_uint16(significand, exponent);
        assertEq(decodedNumber, number, "encode_uint16 should correctly encode and decode the number");
    }

    function test_encode_uint32() public pure {
        uint256 number = 3000000000;
        (uint32 significand, uint8 exponent) = CompactEncodeLib.encode_uint32(number);
        uint256 decodedNumber = CompactEncodeLib.decode_uint32(significand, exponent);
        assertEq(decodedNumber, number, "encode_uint32 should correctly encode and decode the number");
    }

    function test_encode_uint64() public pure {
        uint256 number = 12345678901234567890;
        (uint64 significand, uint8 exponent) = CompactEncodeLib.encode_uint64(number);
        uint256 decodedNumber = CompactEncodeLib.decode_uint64(significand, exponent);
        assertEq(decodedNumber, number, "encode_uint64 should correctly encode and decode the number");
    }

    function test_decode_uint8() public pure {
        uint8 significand = 100;
        uint8 exponent = 3;
        uint256 expected = uint256(significand) << exponent;
        uint256 result = CompactEncodeLib.decode_uint8(significand, exponent);
        assertEq(result, expected, "decode_uint8 should return the correct decoded value");
    }

    function test_decode_uint16() public pure {
        uint16 significand = 1000;
        uint8 exponent = 5;
        uint256 expected = uint256(significand) << exponent;
        uint256 result = CompactEncodeLib.decode_uint16(significand, exponent);
        assertEq(result, expected, "decode_uint16 should return the correct decoded value");
    }

    function test_decode_uint32() public pure {
        uint32 significand = 200000;
        uint8 exponent = 8;
        uint256 expected = uint256(significand) << exponent;
        uint256 result = CompactEncodeLib.decode_uint32(significand, exponent);
        assertEq(result, expected, "decode_uint32 should return the correct decoded value");
    }

    function test_decode_uint64() public pure {
        uint64 significand = 5000000000;
        uint8 exponent = 10;
        uint256 expected = uint256(significand) << exponent;
        uint256 result = CompactEncodeLib.decode_uint64(significand, exponent);
        assertEq(result, expected, "decode_uint64 should return the correct decoded value");
    }
}
