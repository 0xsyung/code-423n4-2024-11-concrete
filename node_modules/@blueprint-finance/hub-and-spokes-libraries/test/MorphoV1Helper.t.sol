// SPDX-License-Identifier: AGPL-3.0
pragma solidity 0.8.24;

import {Test} from "forge-std/Test.sol";
import {console2 as console} from "forge-std/console2.sol";
import {IERC20, ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import {IClaimMorphoRewards, MorphoV1Helper} from "../src/libraries/MorphoV1Helper.sol";
import {Errors} from "../src/libraries/Errors.sol";
import {WAD} from "../src/utils/Constants.sol";

interface IMintToken {
    function mint(address account, uint256 amount) external;
}

contract WstETHToken is ERC20, IMintToken {
    constructor() ERC20("Wrapped liquid staked Ether 2.0", "wstETH") {}

    function mint(address account, uint256 amount) public override(IMintToken) {
        _mint(account, amount);
    }
}

abstract contract ExampleTxData {
    // Example transaction data from the previous example
    function _getExampleTxData() internal pure returns (bytes memory exampleTxData) {
        exampleTxData =
            hex"fabed412000000000000000000000000c977d218fde6a39c7ace71c8243545c276b489310000000000000000000000007f39c581f595b53c5cb19bd0b3f8da6c935e2ca0000000000000000000000000000000000000000000000000c370dc6d742bd37a0000000000000000000000000000000000000000000000000000000000000080000000000000000000000000000000000000000000000000000000000000000af968b6f8e54a19fa05d379323f2d2631800789879ddefd75c0e67901c6215e81b232641b2df8e777dcf8b5042eef0cc0c2ec0f591f0593f6c87ac8adb3fb2b7cdb6c71b850331cc38f42a8841428c087d38dbc9e7ce1a27c3a53dcb6f0ec1fcef715c3ff948b492de392057466c4da5ab64663239847b667627c5debd624b9a3cf614ed7836f47e5e4bbda3a5eed9dc8b524d6e5c1de1c72a46aa5c7637facad89424596d010cf08f090a2652fe7ce0c1c56379208fedabd46e1dc627a4fd7d8f869d2fb64d58e69c12b6e3b855c480c42a98194d2475b1798dfaf6ac69289c2c46b28f56da9ecb97ef4a857f35a195dd805ad9f3a5da26031870c405679fd8fb7421902a3d8a4840dcf4056af132df87b8d39c035eab64f9aa3cc3a8f326e94da2f4605a883f273ba9947566b38c1d3db041c11e5911cec812826d5ec2d5c63";
    }
}

contract MorphoV1HelperConsumer {
    function decodeMorphoV1Proofs(bytes memory proofs)
        public
        pure
        returns (address[] memory urd, bytes[] memory txData)
    {
        return MorphoV1Helper.decodeMorphoV1Proofs(proofs);
    }

    function encodeMorphoV1Proofs(address[] memory urd, bytes[] memory txData)
        public
        pure
        returns (bytes memory proofs)
    {
        return MorphoV1Helper.encodeMorphoV1Proofs(urd, txData);
    }

    function decodeTransactionData(bytes memory txData)
        public
        pure
        returns (address account, address token, uint256 claimable)
    {
        return MorphoV1Helper.decodeTransactionData(txData);
    }

    function decodeTransactionDataAndProof(bytes memory txData)
        public
        pure
        returns (address account, address reward, uint256 claimable, bytes32[] memory proof)
    {
        return MorphoV1Helper.decodeTransactionDataAndProof(txData);
    }

    function receiverIsValid(bytes memory txData, address receiver) public pure returns (bool) {
        return MorphoV1Helper.receiverIsValid(txData, receiver);
    }

    function claimRewards(bytes memory txData, bool revertIfReceiverInvalid) public {
        MorphoV1Helper.claimRewards(txData, revertIfReceiverInvalid);
    }

    function claimRewardsAndSend(address owner, bytes memory txDataEncoded, uint8 mode, bool revertIfReceiverInvalid)
        public
    {
        MorphoV1Helper.claimRewardsAndSend(owner, txDataEncoded, mode, revertIfReceiverInvalid);
    }
}

contract MockUrd is IClaimMorphoRewards, ExampleTxData {
    bytes private expectedTxData;

    function claim(address account, address reward, uint256 claimable, bytes32[] memory proof)
        external
        override
        returns (uint256 amount)
    {
        // Verify that the msg.data matches the expected transaction data
        require(
            keccak256(msg.data) == keccak256(_getExampleTxData()),
            "MockUrd: msg.data does not match expected transaction data"
        );

        // amount = claimable;
        // first mint, then transfer
        // transfer claimable to account
        amount = claimable;
        IMintToken(reward).mint(address(this), amount);
        IERC20(reward).transfer(account, amount);
    }
}

contract MorphoV1HelperTest is Test, ExampleTxData {
    MorphoV1HelperConsumer morphoV1HelperConsumer;
    WstETHToken wstETH;

    function setUp() public {
        // Deploy the contract to test
        morphoV1HelperConsumer = new MorphoV1HelperConsumer();
        wstETH = new WstETHToken();
    }

    function test_decodeTransactionData() public view {
        // Expected values based on the provided transaction data
        (address expectedAccount, address expectedToken, uint256 expectedClaimable) = getExpected();

        // Decode the transaction data using the library
        (address account, address token, uint256 claimable) =
            morphoV1HelperConsumer.decodeTransactionData(_getExampleTxData());

        // Check if the decoded values match the expected values
        assertEq(account, expectedAccount, "Decoded account address does not match expected value");
        assertEq(token, expectedToken, "Decoded token address does not match expected value");
        assertEq(claimable, expectedClaimable, "Decoded claimable amount does not match expected value");
    }

    function test_receiverIsValid() public view {
        address receiver = 0xC977d218Fde6A39c7aCE71C8243545c276B48931;

        // Check if the receiver is valid based on the decoded transaction data
        bool isValid = morphoV1HelperConsumer.receiverIsValid(_getExampleTxData(), receiver);

        // Assert that the receiver should be valid
        assertTrue(isValid, "Receiver should be valid");
    }

    function test_encodeDecodeMorphoV1Proofs() public view {
        // Sample data to encode and decode
        address[] memory urd = new address[](2);
        urd[0] = 0xC977d218Fde6A39c7aCE71C8243545c276B48931;
        urd[1] = 0x2EfD4625d0c149EbADf118EC5446c6de24d916A4;

        bytes[] memory data = new bytes[](2);
        data[0] = _getExampleTxData();
        data[1] = _getExampleTxData();

        // Encode the sample data
        bytes memory encodedProofs = morphoV1HelperConsumer.encodeMorphoV1Proofs(urd, data);

        // Decode the encoded proofs
        (address[] memory decodedUrd, bytes[] memory decodedData) =
            morphoV1HelperConsumer.decodeMorphoV1Proofs(encodedProofs);

        // Check if the decoded values match the original values
        assertEq(decodedUrd.length, urd.length, "Decoded URD array length does not match original length");
        assertEq(decodedData.length, data.length, "Decoded data array length does not match original length");

        for (uint256 i = 0; i < urd.length; i++) {
            assertEq(decodedUrd[i], urd[i], "Decoded URD address does not match original address");
            assertEq(decodedData[i], data[i], "Decoded data does not match original data");
        }
    }

    function test_decodeTransactionDataAndProof() public view {
        // Expected values based on the provided transaction data
        (address expectedAccount, address expectedToken, uint256 expectedClaimable) = getExpected();
        bytes32[] memory expectedProof = new bytes32[](10);
        expectedProof[0] = 0xf968b6f8e54a19fa05d379323f2d2631800789879ddefd75c0e67901c6215e81;
        expectedProof[1] = 0xb232641b2df8e777dcf8b5042eef0cc0c2ec0f591f0593f6c87ac8adb3fb2b7c;
        expectedProof[2] = 0xdb6c71b850331cc38f42a8841428c087d38dbc9e7ce1a27c3a53dcb6f0ec1fce;
        expectedProof[3] = 0xf715c3ff948b492de392057466c4da5ab64663239847b667627c5debd624b9a3;
        expectedProof[4] = 0xcf614ed7836f47e5e4bbda3a5eed9dc8b524d6e5c1de1c72a46aa5c7637facad;
        expectedProof[5] = 0x89424596d010cf08f090a2652fe7ce0c1c56379208fedabd46e1dc627a4fd7d8;
        expectedProof[6] = 0xf869d2fb64d58e69c12b6e3b855c480c42a98194d2475b1798dfaf6ac69289c2;
        expectedProof[7] = 0xc46b28f56da9ecb97ef4a857f35a195dd805ad9f3a5da26031870c405679fd8f;
        expectedProof[8] = 0xb7421902a3d8a4840dcf4056af132df87b8d39c035eab64f9aa3cc3a8f326e94;
        expectedProof[9] = 0xda2f4605a883f273ba9947566b38c1d3db041c11e5911cec812826d5ec2d5c63;

        // Decode the transaction data and proof using the library
        (address account, address token, uint256 claimable, bytes32[] memory proof) =
            morphoV1HelperConsumer.decodeTransactionDataAndProof(_getExampleTxData());

        // Check if the decoded values match the expected values
        assertEq(account, expectedAccount, "Decoded account address does not match expected value");
        assertEq(token, expectedToken, "Decoded token address does not match expected value");
        assertEq(claimable, expectedClaimable, "Decoded claimable amount does not match expected value");
        assertEq(proof.length, expectedProof.length, "Decoded proof length does not match expected length");

        for (uint256 i = 0; i < proof.length; i++) {
            assertEq(proof[i], expectedProof[i], "Decoded proof element does not match expected element");
        }
    }

    function test_claimRewards_withMockUrd() public {
        (address expectedAccount, address expectedToken, uint256 expectedClaimable) = getExpected();
        vm.etch(expectedToken, address(wstETH).code);
        vm.etch(expectedAccount, address(morphoV1HelperConsumer).code);
        // Prepare the expected transaction data
        bytes memory exampleTxData = _getExampleTxData();

        // Deploy two instances of MockUrd, each initialized with the expected transaction data
        MockUrd mockUrd1 = new MockUrd();
        MockUrd mockUrd2 = new MockUrd();

        // Setup the arrays for testing
        address[] memory urd = new address[](2);
        urd[0] = address(mockUrd1);
        urd[1] = address(mockUrd2);

        bytes[] memory txDataArray = new bytes[](2);
        txDataArray[0] = exampleTxData;
        txDataArray[1] = exampleTxData;

        // Encode the array of proofs
        bytes memory encodedProofs = morphoV1HelperConsumer.encodeMorphoV1Proofs(urd, txDataArray);

        // Test claiming rewards
        vm.prank(expectedAccount);
        MorphoV1HelperConsumer(expectedAccount).claimRewards(encodedProofs, true); // Should succeed because the mock checks for matching data
        vm.prank(address(this));
        // now pranking wrong account, but passing false flag for revertIfReceiverInvalid
        MorphoV1HelperConsumer(expectedAccount).claimRewards(encodedProofs, false);
    }

    function test_claimRewardsWithReturns_withMockUrd() public {
        (address expectedAccount, address expectedToken, uint256 expectedClaimable) = getExpected();
        vm.etch(expectedToken, address(wstETH).code);
        vm.etch(expectedAccount, address(morphoV1HelperConsumer).code);

        // Prepare the expected transaction data
        bytes memory exampleTxData = _getExampleTxData();
        MockUrd mockUrd1 = new MockUrd();
        address[] memory urd = new address[](1);
        urd[0] = address(mockUrd1);
        bytes[] memory txDataArray = new bytes[](1);
        txDataArray[0] = exampleTxData;

        // Encode the array of proofs
        bytes memory encodedProofs = MorphoV1HelperConsumer(expectedAccount).encodeMorphoV1Proofs(urd, txDataArray);

        // Test claiming rewards
        assertEq(IERC20(expectedToken).balanceOf(expectedAccount), 0, "Receiver should have 0 balance");
        vm.prank(expectedAccount);
        MorphoV1HelperConsumer(expectedAccount).claimRewardsAndSend(expectedAccount, encodedProofs, 0, true);
        assertEq(
            IERC20(expectedToken).balanceOf(expectedAccount),
            expectedClaimable,
            "Receiver should have the correct balance"
        );
    }

    function testfail_claimRewardsWrongAddress_withMockUrd() public {
        // Prepare the expected transaction data
        bytes memory exampleTxData = _getExampleTxData();

        // Deploy two instances of MockUrd, each initialized with the expected transaction data
        MockUrd mockUrd1 = new MockUrd();
        MockUrd mockUrd2 = new MockUrd();

        // Setup the arrays for testing
        address[] memory urd = new address[](2);
        urd[0] = address(mockUrd1);
        urd[1] = address(mockUrd2);

        bytes[] memory txDataArray = new bytes[](2);
        txDataArray[0] = exampleTxData;
        txDataArray[1] = exampleTxData;

        // Encode the array of proofs
        bytes memory encodedProofs = morphoV1HelperConsumer.encodeMorphoV1Proofs(urd, txDataArray);
        // Test claiming rewards
        vm.prank(address(this));
        vm.expectRevert(abi.encodeWithSelector(Errors.InvalidMorphoRewardsReceiver.selector));
        morphoV1HelperConsumer.claimRewards(encodedProofs, true); // Should succeed because the mock checks for matching data
    }

    ///// Helpers /////

    function getExpected()
        internal
        view
        returns (address expectedAccount, address expectedToken, uint256 expectedClaimable)
    {
        expectedAccount = 0xC977d218Fde6A39c7aCE71C8243545c276B48931;
        expectedToken = 0x7f39C581F595B53c5cb19bD0b3f8dA6c935E2Ca0;
        expectedClaimable = 14082998397446116218;
    }
}
