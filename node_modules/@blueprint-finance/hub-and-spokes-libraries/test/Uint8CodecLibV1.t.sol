// SPDX-License-Identifier: AGPL-3.0
pragma solidity ^0.8.24;

import {Test} from "forge-std/Test.sol";
import {console2 as console} from "forge-std/console2.sol";
import {Uint8CodecLibV1} from "../src/libraries/Uint8CodecLibV1.sol";

contract Uint8CodecLibV1Test is Test {
    // TEST MODE AND ISSUER ////////////////////////////////////////

    function test_encodeModeAndIssuer() public pure {
        uint8 mode = 1;
        uint8 issuer = 2;
        uint256 expected = uint256(mode) | (uint256(issuer) << 8);
        uint256 result = Uint8CodecLibV1.encodeModeAndIssuer(mode, issuer);
        assertEq(result, expected, "encodeModeAndIssuer should return the correct encoded value");
    }

    function test_encodeOnlyMode() public pure {
        uint8 mode = 3;
        uint256 expected = uint256(mode);
        uint256 result = Uint8CodecLibV1.encodeOnlyMode(mode);
        assertEq(result, expected, "encodeOnlyMode should return the correct encoded value");
        // do not even encode it
        assertEq(mode, expected, "encodeOnlyMode should return the correct encoded value");
    }

    function test_decodeModeAndIssuer() public pure {
        uint8 mode = 1;
        uint8 issuer = 2;
        uint256 encodedData = Uint8CodecLibV1.encodeModeAndIssuer(mode, issuer);
        (uint8 decodedMode, uint8 decodedIssuer) = Uint8CodecLibV1.decodeModeAndIssuer(encodedData);
        assertEq(decodedMode, mode, "decodeModeAndIssuer should return the correct mode");
        assertEq(decodedIssuer, issuer, "decodeModeAndIssuer should return the correct issuer");
    }

    function test_decodeIssuer() public pure {
        uint8 mode = 1;
        uint8 issuer = 2;
        uint256 encodedData = Uint8CodecLibV1.encodeModeAndIssuer(mode, issuer);
        uint8 decodedIssuer = Uint8CodecLibV1.decodeIssuer(encodedData);
        assertEq(decodedIssuer, issuer, "decodeIssuer should return the correct issuer");
    }

    function test_decodeMode() public pure {
        uint8 mode = 3;
        uint8 issuer = 4;
        uint256 encodedData = Uint8CodecLibV1.encodeModeAndIssuer(mode, issuer);
        uint8 decodedMode = Uint8CodecLibV1.decodeMode(encodedData);
        assertEq(decodedMode, mode, "decodeMode should return the correct mode");
    }

    function test_updateLoanOption() public pure {
        uint256 originalEncoding = 0x1234567890;
        uint8 newLoanOption = 42;
        uint256 expectedEncoding = Uint8CodecLibV1.updateNthByte(originalEncoding, newLoanOption, 2);
        uint256 result = Uint8CodecLibV1.updateLoanOption(originalEncoding, newLoanOption);
        assertEq(result, expectedEncoding, "updateLoanOption should return the correct updated encoding");
    }

    function test_decodeLoanOption() public pure {
        uint256 encodedData = Uint8CodecLibV1.updateLoanOption(0x1234567890, 42);
        uint8 decodedLoanOption = Uint8CodecLibV1.decodeLoanOption(encodedData);
        assertEq(decodedLoanOption, 42, "decodeLoanOption should return the correct loan option");
    }

    function test_updateLoanEMode() public pure {
        uint256 originalEncoding = 0x1234567890;
        uint8 newLoanEMode = 24;
        uint256 expectedEncoding = Uint8CodecLibV1.updateNthByte(originalEncoding, newLoanEMode, 3);
        uint256 result = Uint8CodecLibV1.updateLoanEMode(originalEncoding, newLoanEMode);
        assertEq(result, expectedEncoding, "updateLoanEMode should return the correct updated encoding");
    }

    function test_decodeLoanEMode() public pure {
        uint256 encodedData = Uint8CodecLibV1.updateLoanEMode(0x1234567890, 24);
        uint8 decodedLoanEMode = Uint8CodecLibV1.decodeLoanEMode(encodedData);
        assertEq(decodedLoanEMode, 24, "decodeLoanEMode should return the correct loan e-mode");
    }
}
