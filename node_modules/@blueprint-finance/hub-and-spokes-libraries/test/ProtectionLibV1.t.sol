// SPDX-License-Identifier: AGPL-3.0
pragma solidity ^0.8.24;

import {Test} from "forge-std/Test.sol";
import {console2 as console} from "forge-std/console2.sol";

import {Errors} from "../src/libraries/Errors.sol";
import {Math} from "@openzeppelin/contracts/utils/math/Math.sol";
import {MILLION, BP, WAD, TYPE_UINT2_MAX, TYPE_UINT4_MAX, TYPE_UINT20_MAX} from "../src/utils/Constants.sol";
import {ProtectionLibV1} from "../src/libraries/ProtectionLibV1.sol";

import {ProtectionData, ProtectionDataAbsolute} from "../src/utils/DataTypes.sol";

struct TempRights {
    bool protocolCanCloseAndForeclose;
    bool protocolCanClaimAndReclaim;
    bool remoteProxyCanCloseAndForeclose;
    bool remoteProxyCanClaimAndReclaim;
    bool remoteConcreteerCanCloseAndForeclose;
    bool remoteConcreteerCanClaimAndReclaim;
    bool remotePublicCanCloseAndForeclose;
    bool remotePublicCanClaimAndReclaim;
}

contract ProtectionLibV1Test is Test {
    using ProtectionLibV1 for uint256;
    using Math for uint256;

    function test_encodeProtectionData() public pure {
        uint32[] memory trancheAmountFractionInMillionth = new uint32[](3);
        uint32[] memory trancheFeeRateInMillionth = new uint32[](3);
        trancheAmountFractionInMillionth[0] = 300000;
        trancheAmountFractionInMillionth[1] = 300000;
        trancheAmountFractionInMillionth[2] = 400000;
        trancheFeeRateInMillionth[0] = 3000;
        trancheFeeRateInMillionth[1] = 3000;
        trancheFeeRateInMillionth[2] = 4000;
        ProtectionData memory protectionData = ProtectionData({
            endTime: 1000,
            numberOfTranches: 3,
            rightsEncoding: 1,
            ltvProtectClaims: 7500,
            ltvProtectForeclosure: 7500,
            openingFeeRate: 6000,
            cancellationFeeRate: 6000,
            trancheAmountFractionInMillionth: trancheAmountFractionInMillionth,
            trancheFeeRateInMillionth: trancheFeeRateInMillionth
        });

        uint256 encodedProtectionData = ProtectionLibV1.encodeProtectionData(protectionData);

        (
            uint40 endTime,
            uint8 numberOfTranches,
            uint8 encodedRights,
            uint32 ltvProtectClaims,
            uint32 ltvProtectForeclosure,
            uint32 openingFeeRate,
            uint32 cancellationFeeRate,
            uint32 trancheOneAmountFractionInMillionth,
            uint32 trancheOneFeeRateInMillionth,
            uint32 trancheTwoAmountFractionInMillionth,
            uint32 trancheTwoFeeRateInMillionth,
            uint32 trancheThreeAmountFractionInMillionth,
            uint32 trancheThreeFeeRateInMillionth
        ) = encodedProtectionData.decodeProtectionData();

        assertEq(endTime, 1000, "End time should be 1000");
        assertEq(numberOfTranches, 3, "Number of tranches should be 3");
        assertEq(encodedRights, 1, "Rights should be 1");
        assertEq(ltvProtectClaims, 7500, "LTV protect claims should be 7500");
        assertEq(ltvProtectForeclosure, 7500, "LTV protect foreclosure should be 7500");
        assertEq(openingFeeRate, 6000, "Opening fee rate should be 6000");
        assertEq(cancellationFeeRate, 6000, "Cancellation fee rate should be 6000");
        assertEq(trancheOneAmountFractionInMillionth, 300000, "Tranche one amount fraction should be 300000");
        assertEq(trancheOneFeeRateInMillionth, 3000, "Tranche one fee rate should be 3000");
        assertEq(trancheTwoAmountFractionInMillionth, 300000, "Tranche two amount fraction should be 300000");
        assertEq(trancheTwoFeeRateInMillionth, 3000, "Tranche two fee rate should be 3000");
        assertEq(trancheThreeAmountFractionInMillionth, 400000, "Tranche three amount fraction should be 400000");
        assertEq(trancheThreeFeeRateInMillionth, 4000, "Tranche three fee rate should be 4000");

        numberOfTranches = encodedProtectionData.getNumberOfTranches();
        assertEq(numberOfTranches, 3, "Number of tranches should be 3");
    }

    function test_encodeProtectionDataFromAbsoluteValues() public pure {
        uint256 promisedAmountInToken = 10_000_000;
        uint256[] memory trancheAmountInToken = new uint256[](3);
        uint256[] memory trancheFeeInToken = new uint256[](3);
        trancheAmountInToken[0] = 3_000_000;
        trancheAmountInToken[1] = 3_000_000;
        trancheAmountInToken[2] = 4_000_000;
        trancheFeeInToken[0] = 30_000;
        trancheFeeInToken[1] = 30_000;
        trancheFeeInToken[2] = 40_000;
        ProtectionDataAbsolute memory protectionDataAbsolute = ProtectionDataAbsolute({
            endTime: 1000,
            numberOfTranches: 3,
            protocolRights: 1,
            remoteProxyRights: 0,
            remoteConcreteerRights: 0,
            remotePublicRights: 0,
            ltvProtectForClaimsInBP: 7500,
            ltvProtectForForeclosureInBP: 7500,
            openingFeeInToken: promisedAmountInToken.mulDiv(6000, MILLION),
            cancellationFeeInToken: promisedAmountInToken.mulDiv(6000, MILLION),
            trancheAmountInToken: trancheAmountInToken,
            trancheFeeInToken: trancheFeeInToken
        });

        uint256 encodedProtectionData =
            ProtectionLibV1.encodeProtectionDataFromAbsoluteValues(promisedAmountInToken, protectionDataAbsolute);

        (
            uint40 endTime,
            uint8 numberOfTranches,
            uint8 encodedRights,
            uint32 ltvProtectClaims,
            uint32 ltvProtectForeclosure,
            uint32 openingFeeRate,
            uint32 cancellationFeeRate,
            uint32 trancheOneAmountFractionInMillionth,
            uint32 trancheOneFeeRateInMillionth,
            uint32 trancheTwoAmountFractionInMillionth,
            uint32 trancheTwoFeeRateInMillionth,
            uint32 trancheThreeAmountFractionInMillionth,
            uint32 trancheThreeFeeRateInMillionth
        ) = encodedProtectionData.decodeProtectionData();

        assertEq(endTime, 1000, "End time should be 1000");
        assertEq(numberOfTranches, 3, "Number of tranches should be 3");
        assertEq(encodedRights, 1, "Rights should be 1");
        assertEq(ltvProtectClaims, uint256(7500).mulDiv(MILLION, BP), "LTV protect claims should be 75% in MILLIONTH");
        assertEq(
            ltvProtectForeclosure,
            uint256(7500).mulDiv(MILLION, BP),
            "LTV protect foreclosure should be 75% in MILLIONTH"
        );
        assertEq(openingFeeRate, 6000, "Opening fee rate should be 6000");
        assertEq(cancellationFeeRate, 6000, "Cancellation fee rate should be 6000");
        assertEq(trancheOneAmountFractionInMillionth, 300000, "Tranche one amount fraction should be 300000");
        assertEq(trancheOneFeeRateInMillionth, 3000, "Tranche one fee rate should be 3000");
        assertEq(trancheTwoAmountFractionInMillionth, 300000, "Tranche two amount fraction should be 300000");
        assertEq(trancheTwoFeeRateInMillionth, 3000, "Tranche two fee rate should be 3000");
        assertEq(trancheThreeAmountFractionInMillionth, 400000, "Tranche three amount fraction should be 400000");
        assertEq(trancheThreeFeeRateInMillionth, 4000, "Tranche three fee rate should be 4000");
    }

    function test_updateLtvProtectForClaims() public pure {
        uint256 encoding = 0;
        uint256 ltvProtectBufferForClaimsInWad = uint256(20_000).mulDiv(WAD, MILLION); // 2% in WAD
        uint256 updatedEncoding = encoding.updateLtvProtectForClaims(ltvProtectBufferForClaimsInWad);
        uint256 ltvProtectForClaimsInMillionth = updatedEncoding.getLtvProtectForClaimsInMillionth();
        uint256 ltvProtectBufferForClaimsInWadAfter = updatedEncoding.getLtvProtectBufferForClaimsInWad();
        assertEq(ltvProtectForClaimsInMillionth, 20_000, "LTV protect for claims should be 500000 in MILLIONTH");
        assertEq(
            ltvProtectBufferForClaimsInWadAfter,
            ltvProtectBufferForClaimsInWad,
            "LTV protect buffer for claims should be the same"
        );
    }

    function test_updateLtvProtectForForeclosure() public pure {
        uint256 encoding = 0;
        uint256 ltvProtectBufferForForeclosureInWad = uint256(20_000).mulDiv(WAD, MILLION); // 2% in WAD
        uint256 updatedEncoding = encoding.updateLtvProtectForForeclosure(ltvProtectBufferForForeclosureInWad);
        uint256 ltvProtectForForeclosureInMillionth = updatedEncoding.getLtvProtectForForeclosureInMillionth();
        uint256 ltvProtectBufferForForeclosureInWadAfter = updatedEncoding.getLtvProtectBufferForForeclosureInWad();
        assertEq(
            ltvProtectForForeclosureInMillionth, 20_000, "LTV protect for foreclosure should be 500000 in MILLIONTH"
        );
        assertEq(
            ltvProtectBufferForForeclosureInWadAfter,
            ltvProtectBufferForForeclosureInWad,
            "LTV protect buffer for foreclosure should be the same"
        );
    }

    function test_updateNumberOfClaims() public pure {
        uint256 encoding = 0;
        uint8 numberOfClaims = 3;
        uint256 updatedEncoding = encoding.updateNumberOfClaims(numberOfClaims);
        uint8 updatedNumberOfClaims = updatedEncoding.getNumberOfClaims();
        assertEq(updatedNumberOfClaims, 3, "Number of claims should be 3");
    }

    function test_incrementNumberOfClaims() public pure {
        uint256 encoding = 0;
        uint256 updatedEncoding = encoding.incrementNumberOfClaims();
        uint8 updatedNumberOfClaims = updatedEncoding.getNumberOfClaims();
        assertEq(updatedNumberOfClaims, 1, "Number of claims should be 1");
    }

    function test_getTrancheAmountFractionInWad() public pure {
        uint32[] memory trancheAmountFractionInMillionth = new uint32[](3);
        uint32[] memory trancheFeeRateInMillionth = new uint32[](3);
        trancheAmountFractionInMillionth[0] = 300_000;
        trancheAmountFractionInMillionth[1] = 300_000;
        trancheAmountFractionInMillionth[2] = 400_000;

        ProtectionData memory protectionData;
        protectionData.trancheAmountFractionInMillionth = trancheAmountFractionInMillionth;
        protectionData.trancheFeeRateInMillionth = trancheFeeRateInMillionth;
        protectionData.numberOfTranches = 3;

        uint256 encodedProtectionData = ProtectionLibV1.encodeProtectionData(protectionData);

        uint256 trancheOneAmountFractionInWad = encodedProtectionData.getTrancheAmountFractionInWad(1);
        uint256 trancheTwoAmountFractionInWad = encodedProtectionData.getTrancheAmountFractionInWad(2);
        uint256 trancheThreeAmountFractionInWad = encodedProtectionData.getTrancheAmountFractionInWad(3);

        assertEq(
            trancheOneAmountFractionInWad,
            uint256(trancheAmountFractionInMillionth[0]).mulDiv(WAD, MILLION),
            "Tranche one amount fraction should be 30% in WAD"
        );
        assertEq(
            trancheTwoAmountFractionInWad,
            uint256(trancheAmountFractionInMillionth[1]).mulDiv(WAD, MILLION),
            "Tranche two amount fraction should be 30% in WAD"
        );
        assertEq(
            trancheThreeAmountFractionInWad,
            uint256(trancheAmountFractionInMillionth[2]).mulDiv(WAD, MILLION),
            "Tranche three amount fraction should be 40% in WAD"
        );
    }

    function test_trancheFeeFractionInWad() public pure {
        uint32[] memory trancheAmountFractionInMillionth = new uint32[](3);
        uint32[] memory trancheFeeRateInMillionth = new uint32[](3);
        trancheFeeRateInMillionth[0] = 3000;
        trancheFeeRateInMillionth[1] = 3000;
        trancheFeeRateInMillionth[2] = 4000;

        ProtectionData memory protectionData;
        protectionData.trancheAmountFractionInMillionth = trancheAmountFractionInMillionth;
        protectionData.trancheFeeRateInMillionth = trancheFeeRateInMillionth;
        protectionData.numberOfTranches = 3;

        uint256 encodedProtectionData = ProtectionLibV1.encodeProtectionData(protectionData);

        uint256 trancheOneFeeFractionInWad = encodedProtectionData.getTrancheFeeFractionInWad(1);
        uint256 trancheTwoFeeFractionInWad = encodedProtectionData.getTrancheFeeFractionInWad(2);
        uint256 trancheThreeFeeFractionInWad = encodedProtectionData.getTrancheFeeFractionInWad(3);

        assertEq(
            trancheOneFeeFractionInWad,
            uint256(trancheFeeRateInMillionth[0]).mulDiv(WAD, MILLION),
            "Tranche one fee fraction should be 30% in WAD"
        );
        assertEq(
            trancheTwoFeeFractionInWad,
            uint256(trancheFeeRateInMillionth[1]).mulDiv(WAD, MILLION),
            "Tranche two fee fraction should be 30% in WAD"
        );
        assertEq(
            trancheThreeFeeFractionInWad,
            uint256(trancheFeeRateInMillionth[2]).mulDiv(WAD, MILLION),
            "Tranche three fee fraction should be 40% in WAD"
        );
    }

    function test_getTrancheAmount() public pure {
        uint32[] memory trancheAmountFractionInMillionth = new uint32[](3);
        uint32[] memory trancheFeeRateInMillionth = new uint32[](3);
        trancheAmountFractionInMillionth[0] = 300_000;
        trancheAmountFractionInMillionth[1] = 300_000;
        trancheAmountFractionInMillionth[2] = 400_000;

        ProtectionData memory protectionData;
        protectionData.trancheAmountFractionInMillionth = trancheAmountFractionInMillionth;
        protectionData.trancheFeeRateInMillionth = trancheFeeRateInMillionth;
        protectionData.numberOfTranches = 3;

        uint256 encodedProtectionData = ProtectionLibV1.encodeProtectionData(protectionData);

        uint256 trancheOneAmount = encodedProtectionData.getTrancheAmount(1, 10_000_000);
        uint256 trancheTwoAmount = encodedProtectionData.getTrancheAmount(2, 10_000_000);
        uint256 trancheThreeAmount = encodedProtectionData.getTrancheAmount(3, 10_000_000);

        assertEq(trancheOneAmount, 3_000_000, "Tranche one amount should be 3_000_000");
        assertEq(trancheTwoAmount, 3_000_000, "Tranche two amount should be 3_000_000");
        assertEq(trancheThreeAmount, 4_000_000, "Tranche three amount should be 4_000_000");
    }

    function test_getTranchFee() public pure {
        uint32[] memory trancheAmountFractionInMillionth = new uint32[](3);
        uint32[] memory trancheFeeRateInMillionth = new uint32[](3);
        trancheFeeRateInMillionth[0] = 3000;
        trancheFeeRateInMillionth[1] = 3000;
        trancheFeeRateInMillionth[2] = 4000;

        ProtectionData memory protectionData;
        protectionData.trancheAmountFractionInMillionth = trancheAmountFractionInMillionth;
        protectionData.trancheFeeRateInMillionth = trancheFeeRateInMillionth;
        protectionData.numberOfTranches = 3;

        uint256 encodedProtectionData = ProtectionLibV1.encodeProtectionData(protectionData);

        uint256 trancheOneFee = encodedProtectionData.getTrancheFee(1, 10_000_000);
        uint256 trancheTwoFee = encodedProtectionData.getTrancheFee(2, 10_000_000);
        uint256 trancheThreeFee = encodedProtectionData.getTrancheFee(3, 10_000_000);

        assertEq(trancheOneFee, 30_000, "Tranche one fee should be 30_000");
        assertEq(trancheTwoFee, 30_000, "Tranche two fee should be 30_000");
        assertEq(trancheThreeFee, 40_000, "Tranche three fee should be 40_000");
    }

    function test_castLtvProtectIntoBuffer() public pure {
        uint256 encodedProtection = 0;
        uint256 lenderLiqLtvInWad = uint256(800_000).mulDiv(WAD, MILLION);
        uint256 ltvProtectClaimsInWad = uint256(750_000).mulDiv(WAD, MILLION);
        uint256 ltvProtectForeclosureInWad = uint256(750_000).mulDiv(WAD, MILLION);
        encodedProtection = encodedProtection.updateLtvProtectForClaims(ltvProtectClaimsInWad);
        encodedProtection = encodedProtection.updateLtvProtectForForeclosure(ltvProtectForeclosureInWad);

        uint256 fallbackBuffer = uint256(5_000).mulDiv(WAD, MILLION);
        uint256 newEncodedProtection = encodedProtection.castLtvProtectIntoBuffer(lenderLiqLtvInWad, fallbackBuffer);

        uint256 newLtvBufferForClaimsInWad = newEncodedProtection.getLtvProtectBufferForClaimsInWad();
        uint256 expectedBufferInWad = WAD - ltvProtectClaimsInWad.mulDiv(WAD, lenderLiqLtvInWad);
        uint256 newLtvBufferForForeclosureInWad = newEncodedProtection.getLtvProtectBufferForForeclosureInWad();
        assertEq(newLtvBufferForClaimsInWad, expectedBufferInWad, "LTV buffer for claims should be the same");
        assertEq(newLtvBufferForForeclosureInWad, expectedBufferInWad, "LTV buffer for foreclosure should be the same");
    }

    function test_castLtvProtectIntoBufferFallbackClaim() public pure {
        uint256 encodedProtection = 0;
        uint256 lenderLiqLtvInWad = uint256(800_000).mulDiv(WAD, MILLION);
        uint256 ltvProtectClaimsInWad = uint256(850_000).mulDiv(WAD, MILLION);
        uint256 ltvProtectForeclosureInWad = uint256(750_000).mulDiv(WAD, MILLION);
        encodedProtection = encodedProtection.updateLtvProtectForClaims(ltvProtectClaimsInWad);

        uint256 fallbackBuffer = uint256(5_000).mulDiv(WAD, MILLION);
        encodedProtection = encodedProtection.updateLtvProtectForForeclosure(ltvProtectForeclosureInWad);
        uint256 newEncodedProtection = encodedProtection.castLtvProtectIntoBuffer(lenderLiqLtvInWad, fallbackBuffer);

        uint256 newLtvBufferForClaimsInWad = newEncodedProtection.getLtvProtectBufferForClaimsInWad();

        uint256 newLtvBufferForForeclosureInWad = newEncodedProtection.getLtvProtectBufferForForeclosureInWad();
        assertEq(newLtvBufferForClaimsInWad, fallbackBuffer, "LTV buffer for claims should be the same");
        assertEq(
            newLtvBufferForForeclosureInWad,
            WAD - ltvProtectForeclosureInWad.mulDiv(WAD, lenderLiqLtvInWad),
            "LTV buffer for foreclosure should be the same"
        );
    }

    function test_castLtvProtectIntoBufferFallbackForeclosure() public pure {
        uint256 encodedProtection = 0;
        uint256 lenderLiqLtvInWad = uint256(800_000).mulDiv(WAD, MILLION);
        uint256 ltvProtectClaimsInWad = uint256(750_000).mulDiv(WAD, MILLION);
        uint256 ltvProtectForeclosureInWad = uint256(850_000).mulDiv(WAD, MILLION);
        encodedProtection = encodedProtection.updateLtvProtectForForeclosure(ltvProtectForeclosureInWad);

        uint256 fallbackBuffer = uint256(5_000).mulDiv(WAD, MILLION);
        encodedProtection = encodedProtection.updateLtvProtectForClaims(ltvProtectClaimsInWad);
        uint256 newEncodedProtection = encodedProtection.castLtvProtectIntoBuffer(lenderLiqLtvInWad, fallbackBuffer);

        uint256 newLtvBufferForClaimsInWad = newEncodedProtection.getLtvProtectBufferForClaimsInWad();
        uint256 expectedBufferInWad = WAD - ltvProtectClaimsInWad.mulDiv(WAD, lenderLiqLtvInWad);
        uint256 newLtvBufferForForeclosureInWad = newEncodedProtection.getLtvProtectBufferForForeclosureInWad();
        assertEq(newLtvBufferForClaimsInWad, expectedBufferInWad, "LTV buffer for claims should be the same");
        assertEq(newLtvBufferForForeclosureInWad, fallbackBuffer, "LTV buffer for foreclosure should be the same");
    }

    function test_getOpeningFeeFractionInWad() public pure {
        uint32[] memory trancheAmountFractionInMillionth = new uint32[](3);
        uint32[] memory trancheFeeRateInMillionth = new uint32[](3);
        // encode opening fee fraction as 0.6%
        ProtectionData memory protectionData;
        protectionData.openingFeeRate = 6_000;
        protectionData.trancheAmountFractionInMillionth = trancheAmountFractionInMillionth;
        protectionData.trancheFeeRateInMillionth = trancheFeeRateInMillionth;
        protectionData.numberOfTranches = 3;

        uint256 encodedProtectionData = ProtectionLibV1.encodeProtectionData(protectionData);
        uint256 openingFeeFractionInWad = encodedProtectionData.getOpeningFeeFractionInWad();
        assertEq(
            openingFeeFractionInWad, uint256(6_000).mulDiv(WAD, MILLION), "Opening fee fraction should be 0.6% in WAD"
        );
    }

    function test_getCancellationFeeFractionInWad() public pure {
        uint32[] memory trancheAmountFractionInMillionth = new uint32[](3);
        uint32[] memory trancheFeeRateInMillionth = new uint32[](3);
        // encode cancellation fee fraction as 0.6%
        ProtectionData memory protectionData;
        protectionData.cancellationFeeRate = 6_000;
        protectionData.trancheAmountFractionInMillionth = trancheAmountFractionInMillionth;
        protectionData.trancheFeeRateInMillionth = trancheFeeRateInMillionth;
        protectionData.numberOfTranches = 3;

        uint256 encodedProtectionData = ProtectionLibV1.encodeProtectionData(protectionData);
        uint256 cancellationFeeFractionInWad = encodedProtectionData.getCancellationFeeFractionInWad();
        assertEq(
            cancellationFeeFractionInWad,
            uint256(6_000).mulDiv(WAD, MILLION),
            "Cancellation fee fraction should be 0.6% in WAD"
        );
    }

    function test_getOpeningFee() public pure {
        uint32[] memory trancheAmountFractionInMillionth = new uint32[](3);
        uint32[] memory trancheFeeRateInMillionth = new uint32[](3);

        ProtectionData memory protectionData;
        protectionData.trancheAmountFractionInMillionth = trancheAmountFractionInMillionth;
        protectionData.trancheFeeRateInMillionth = trancheFeeRateInMillionth;
        protectionData.numberOfTranches = 3;
        protectionData.openingFeeRate = 6000;

        uint256 encodedProtectionData = ProtectionLibV1.encodeProtectionData(protectionData);
        uint256 openingFee = encodedProtectionData.getOpeningFee(10_000_000);
        uint256 expectedOpeningFee = 60_000;
        assertEq(openingFee, expectedOpeningFee, "Opening fee should be 60_000");
    }

    function test_getCancellationFee() public pure {
        uint32[] memory trancheAmountFractionInMillionth = new uint32[](3);
        uint32[] memory trancheFeeRateInMillionth = new uint32[](3);

        ProtectionData memory protectionData;
        protectionData.trancheAmountFractionInMillionth = trancheAmountFractionInMillionth;
        protectionData.trancheFeeRateInMillionth = trancheFeeRateInMillionth;
        protectionData.numberOfTranches = 3;
        protectionData.cancellationFeeRate = 6000;

        uint256 encodedProtectionData = ProtectionLibV1.encodeProtectionData(protectionData);
        uint256 cancellationFee = encodedProtectionData.getCancellationFee(10_000_000);
        uint256 expectedCancellationFee = 60_000;
        assertEq(cancellationFee, expectedCancellationFee, "Cancellation fee should be 60_000");
    }

    function test_getEndTime() public pure {
        uint32[] memory trancheAmountFractionInMillionth = new uint32[](3);
        uint32[] memory trancheFeeRateInMillionth = new uint32[](3);

        ProtectionData memory protectionData;
        protectionData.trancheAmountFractionInMillionth = trancheAmountFractionInMillionth;
        protectionData.trancheFeeRateInMillionth = trancheFeeRateInMillionth;
        protectionData.numberOfTranches = 3;
        protectionData.endTime = 1000;

        uint256 encodedProtectionData = ProtectionLibV1.encodeProtectionData(protectionData);
        uint40 endTime = encodedProtectionData.getEndTime();
        assertEq(endTime, 1000, "End time should be 1000");
    }

    function test_encodeRights() public pure {
        uint8 protocolRights = 1;
        uint8 remoteProxyRights = 2;
        uint8 remoteConcreteerRights = 3;
        uint8 remotePublicRights = 2;

        uint8 encodedRights =
            ProtectionLibV1._encodeRights(protocolRights, remoteProxyRights, remoteConcreteerRights, remotePublicRights);

        uint8 expectedEncodedRights =
            protocolRights | (remoteProxyRights << 2) | (remoteConcreteerRights << 4) | (remotePublicRights << 6);
        assertEq(encodedRights, expectedEncodedRights, "Encoded rights should be 0x13");
    }

    function test_getRightsEncoding() public pure {
        uint8 protocolRights = 1;
        uint8 remoteProxyRights = 2;
        uint8 remoteConcreteerRights = 3;
        uint8 remotePublicRights = 2;

        uint8 encodedRights =
            ProtectionLibV1._encodeRights(protocolRights, remoteProxyRights, remoteConcreteerRights, remotePublicRights);

        uint8 rightsEncoding = ProtectionLibV1.getRightsEncoding(uint256(encodedRights) << 48);
        assertEq(rightsEncoding, encodedRights, "Rights encoding should be 0x13");
    }

    function test_getEncodedRights() public pure {
        // initially encode the rights and then get them
        // first _getProtocolRightsFromEncodedRights
        // second _getRemoteProxyRightsFromEncodedRights
        // third _getRemoteConcreteerRightsFromEncodedRights
        // fourth _getRemotePublicRightsFromEncodedRights

        uint8 protocolRights = 1;
        uint8 remoteProxyRights = 2;
        uint8 remoteConcreteerRights = 3;
        uint8 remotePublicRights = 2;
        // encode
        uint8 encodedRights =
            ProtectionLibV1._encodeRights(protocolRights, remoteProxyRights, remoteConcreteerRights, remotePublicRights);
        // get rights
        uint8 protocolRightsFromEncodedRights = ProtectionLibV1._getProtocolRightsFromEncodedRights(encodedRights);
        uint8 remoteProxyRightsFromEncodedRights = ProtectionLibV1._getRemoteProxyRightsFromEncodedRights(encodedRights);
        uint8 remoteConcreteerRightsFromEncodedRights =
            ProtectionLibV1._getRemoteConcreteerRightsFromEncodedRights(encodedRights);
        uint8 remotePublicRightsFromEncodedRights =
            ProtectionLibV1._getRemotePublicRightsFromEncodedRights(encodedRights);

        assertEq(protocolRightsFromEncodedRights, protocolRights, "Protocol rights should be 1");
        assertEq(remoteProxyRightsFromEncodedRights, remoteProxyRights, "Remote proxy rights should be 2");
        assertEq(
            remoteConcreteerRightsFromEncodedRights, remoteConcreteerRights, "Remote concreteer rights should be 3"
        );
        assertEq(remotePublicRightsFromEncodedRights, remotePublicRights, "Remote public rights should be 2");
    }

    function test_getRightsFromProtectionEncoding() public pure {
        uint8 protocolRights = 1;
        uint8 remoteProxyRights = 2;
        uint8 remoteConcreteerRights = 3;
        uint8 remotePublicRights = 2;
        // encode
        uint8 encodedRights =
            ProtectionLibV1._encodeRights(protocolRights, remoteProxyRights, remoteConcreteerRights, remotePublicRights);

        // first encode the protection data with only the encoding of the rights
        ProtectionData memory protectionData;
        protectionData.rightsEncoding = encodedRights;

        uint256 encodedProtectionData = ProtectionLibV1.encodeProtectionData(protectionData);

        // get rights
        uint8 protocolRightsFromEncodedRights = encodedProtectionData.getProtocolRights();
        uint8 remoteProxyRightsFromEncodedRights = encodedProtectionData.getRemoteProxyRights();
        uint8 remoteConcreteerRightsFromEncodedRights = encodedProtectionData.getRemoteConcreteerRights();
        uint8 remotePublicRightsFromEncodedRights = encodedProtectionData.getRemotePublicRights();

        assertEq(protocolRightsFromEncodedRights, protocolRights, "Protocol rights should be 1");
        assertEq(remoteProxyRightsFromEncodedRights, remoteProxyRights, "Remote proxy rights should be 2");
        assertEq(
            remoteConcreteerRightsFromEncodedRights, remoteConcreteerRights, "Remote concreteer rights should be 3"
        );
        assertEq(remotePublicRightsFromEncodedRights, remotePublicRights, "Remote public rights should be 2");
    }

    function test_encodeProtocolRights() public pure {
        uint8 encodedRights = ProtectionLibV1._encodeProtocolRights(true, true);
        assertEq(encodedRights, 0, "Encoded rights should be 0");

        encodedRights = ProtectionLibV1._encodeProtocolRights(false, true);
        assertEq(encodedRights, 1, "Encoded rights should be 1");

        encodedRights = ProtectionLibV1._encodeProtocolRights(true, false);
        assertEq(encodedRights, 2, "Encoded rights should be 2");

        encodedRights = ProtectionLibV1._encodeProtocolRights(false, false);
        assertEq(encodedRights, 3, "Encoded rights should be 3");
    }

    function test_encodeNonProtocolRights() public pure {
        uint8 encodedRights = ProtectionLibV1._encodeNonProtocolRights(true, true);
        assertEq(encodedRights, 3, "Encoded rights should be 3");

        encodedRights = ProtectionLibV1._encodeNonProtocolRights(false, true);
        assertEq(encodedRights, 2, "Encoded rights should be 2");

        encodedRights = ProtectionLibV1._encodeNonProtocolRights(true, false);
        assertEq(encodedRights, 1, "Encoded rights should be 1");

        encodedRights = ProtectionLibV1._encodeNonProtocolRights(false, false);
        assertEq(encodedRights, 0, "Encoded rights should be 0");
    }

    function test_encodeRightsFromFineControlFlags() public pure {
        TempRights memory rights;
        for (uint8 i = 0; i <= 7; i++) {
            rights.protocolCanCloseAndForeclose = i == 0;
            rights.protocolCanClaimAndReclaim = i == 1;
            rights.remoteProxyCanCloseAndForeclose = i == 2;
            rights.remoteProxyCanClaimAndReclaim = i == 3;
            rights.remoteConcreteerCanCloseAndForeclose = i == 4;
            rights.remoteConcreteerCanClaimAndReclaim = i == 5;
            rights.remotePublicCanCloseAndForeclose = i == 6;
            rights.remotePublicCanClaimAndReclaim = i == 7;

            uint8 encodedRights = ProtectionLibV1.encodeRightsFromFineControlFlags(
                rights.protocolCanCloseAndForeclose,
                rights.protocolCanClaimAndReclaim,
                rights.remoteProxyCanCloseAndForeclose,
                rights.remoteProxyCanClaimAndReclaim,
                rights.remoteConcreteerCanCloseAndForeclose,
                rights.remoteConcreteerCanClaimAndReclaim,
                rights.remotePublicCanCloseAndForeclose,
                rights.remotePublicCanClaimAndReclaim
            );
            uint8 protocolRights = uint8(uint256(encodedRights) & TYPE_UINT2_MAX);
            uint8 remoteProxyRights = uint8((uint256(encodedRights) >> 2) & TYPE_UINT2_MAX);
            uint8 remoteConcreteerRights = uint8((uint256(encodedRights) >> 4) & TYPE_UINT2_MAX);
            uint8 remotePublicRights = uint8((uint256(encodedRights) >> 6) & TYPE_UINT2_MAX);

            assertEq(
                rights.protocolCanCloseAndForeclose,
                ProtectionLibV1._getProtocolEnabledForClosureAndForeclosure(protocolRights),
                "Protocol can close and foreclose should be the same"
            );
            assertEq(
                rights.protocolCanClaimAndReclaim,
                ProtectionLibV1._getProtocolEnabledForClaimsAndReclaims(protocolRights),
                "Protocol can claim and reclaim should be the same"
            );
            assertEq(
                rights.remoteProxyCanCloseAndForeclose,
                ProtectionLibV1._getNonProtocolEnabledForClosureAndForeclosure(remoteProxyRights),
                "Remote proxy can close and foreclose should be the same"
            );
            assertEq(
                rights.remoteProxyCanClaimAndReclaim,
                ProtectionLibV1._getNonProtocolEnabledForClaimsAndReclaims(remoteProxyRights),
                "Remote proxy can claim and reclaim should be the same"
            );
            assertEq(
                rights.remoteConcreteerCanCloseAndForeclose,
                ProtectionLibV1._getNonProtocolEnabledForClosureAndForeclosure(remoteConcreteerRights),
                "Remote concreteer can close and foreclose should be the same"
            );
            assertEq(
                rights.remoteConcreteerCanClaimAndReclaim,
                ProtectionLibV1._getNonProtocolEnabledForClaimsAndReclaims(remoteConcreteerRights),
                "Remote concreteer can claim and reclaim should be the same"
            );
            assertEq(
                rights.remotePublicCanCloseAndForeclose,
                ProtectionLibV1._getNonProtocolEnabledForClosureAndForeclosure(remotePublicRights),
                "Remote public can close and foreclose should be the same"
            );
            assertEq(
                rights.remotePublicCanClaimAndReclaim,
                ProtectionLibV1._getNonProtocolEnabledForClaimsAndReclaims(remotePublicRights),
                "Remote public can claim and reclaim should be the same"
            );
        }
    }

    function test_updateRightsEncoding() public pure {
        uint8 newRightsEncoding = 99;
        uint256 encoding = 0;
        uint256 updatedEncoding = encoding.updateRightsEncoding(newRightsEncoding);
        uint8 updatedRightsEncoding = updatedEncoding.getRightsEncoding();
        assertEq(updatedRightsEncoding, newRightsEncoding, "Rights encoding should be the same");
    }

    function test_updateRightsEncodingWithUint8() public pure {
        uint8 protocolRights = 1;
        uint8 remoteProxyRights = 2;
        uint8 remoteConcreteerRights = 3;
        uint8 remotePublicRights = 2;
        uint256 encoding = 0;
        uint256 updatedEncoding = encoding.updateRightsEncodingWithUint8(
            protocolRights, remoteProxyRights, remoteConcreteerRights, remotePublicRights
        );
        uint8 updatedProtocolRights = updatedEncoding.getProtocolRights();
        uint8 updatedRemoteProxyRights = updatedEncoding.getRemoteProxyRights();
        uint8 updatedRemoteConcreteerRights = updatedEncoding.getRemoteConcreteerRights();
        uint8 updatedRemotePublicRights = updatedEncoding.getRemotePublicRights();
        assertEq(updatedProtocolRights, protocolRights, "Protocol rights should be the same");
        assertEq(updatedRemoteProxyRights, remoteProxyRights, "Remote proxy rights should be the same");
        assertEq(updatedRemoteConcreteerRights, remoteConcreteerRights, "Remote concreteer rights should be the same");
        assertEq(updatedRemotePublicRights, remotePublicRights, "Remote public rights should be the same");
    }

    function test_updateRightsEncodingWithBooleanFlags() public pure {
        uint256 encoding = 0;
        for (uint8 i = 0; i <= 7; i++) {
            TempRights memory rights;
            rights.protocolCanCloseAndForeclose = i == 0;
            rights.protocolCanClaimAndReclaim = i == 1;
            rights.remoteProxyCanCloseAndForeclose = i == 2;
            rights.remoteProxyCanClaimAndReclaim = i == 3;
            rights.remoteConcreteerCanCloseAndForeclose = i == 4;
            rights.remoteConcreteerCanClaimAndReclaim = i == 5;
            rights.remotePublicCanCloseAndForeclose = i == 6;
            rights.remotePublicCanClaimAndReclaim = i == 7;

            uint8 encodedRights = ProtectionLibV1.encodeRightsFromFineControlFlags(
                rights.protocolCanCloseAndForeclose,
                rights.protocolCanClaimAndReclaim,
                rights.remoteProxyCanCloseAndForeclose,
                rights.remoteProxyCanClaimAndReclaim,
                rights.remoteConcreteerCanCloseAndForeclose,
                rights.remoteConcreteerCanClaimAndReclaim,
                rights.remotePublicCanCloseAndForeclose,
                rights.remotePublicCanClaimAndReclaim
            );

            uint256 updatedEncoding = encoding.updateRightsEncodingWithBooleanFlags(
                rights.protocolCanCloseAndForeclose,
                rights.protocolCanClaimAndReclaim,
                rights.remoteProxyCanCloseAndForeclose,
                rights.remoteProxyCanClaimAndReclaim,
                rights.remoteConcreteerCanCloseAndForeclose,
                rights.remoteConcreteerCanClaimAndReclaim,
                rights.remotePublicCanCloseAndForeclose,
                rights.remotePublicCanClaimAndReclaim
            );
            uint8 updatedEncodedRights = updatedEncoding.getRightsEncoding();
            // check whether the encoded rights from the new encoding are the same
            assertEq(updatedEncodedRights, encodedRights, "Encoded rights should be the same");
        }
    }

    function test_updateConcreteLiteEnabled() public pure {
        uint256 encoding = 2 ** 100 + 1;
        uint256 updatedEncoding = encoding.updateConcreteLiteEnabled(true);
        bool concreteLiteEnabled = updatedEncoding.getConcreteLiteEnabled();
        assertEq(concreteLiteEnabled, true, "Concrete lite enabled should be true");
        updatedEncoding = updatedEncoding.updateConcreteLiteEnabled(false);
        concreteLiteEnabled = updatedEncoding.getConcreteLiteEnabled();
        assertEq(concreteLiteEnabled, false, "Concrete lite enabled should be false");
    }

    function testfail_validateProtectionData_ShouldFailIsEndtimeIsLowerThanTimestamp() public {
        uint32[] memory trancheAmountFractionInMillionth = new uint32[](3);
        uint32[] memory trancheFeeRateInMillionth = new uint32[](3);
        trancheAmountFractionInMillionth[0] = 300000;
        trancheAmountFractionInMillionth[1] = 300000;
        trancheAmountFractionInMillionth[2] = 400000;
        trancheFeeRateInMillionth[0] = 3000;
        trancheFeeRateInMillionth[1] = 3000;
        trancheFeeRateInMillionth[2] = 4000;
        ProtectionData memory protectionData = ProtectionData({
            endTime: 0,
            numberOfTranches: 3,
            rightsEncoding: 1,
            ltvProtectClaims: 7500,
            ltvProtectForeclosure: 7500,
            openingFeeRate: 6000,
            cancellationFeeRate: 6000,
            trancheAmountFractionInMillionth: trancheAmountFractionInMillionth,
            trancheFeeRateInMillionth: trancheFeeRateInMillionth
        });
        uint256 encodedData = ProtectionLibV1._encodeProtectionData(protectionData);
        bytes memory encodedError = abi.encodeWithSelector(Errors.InvalidProtectionEndTime.selector);
        vm.expectRevert(encodedError);
        ProtectionLibV1.validateEncodedProtection(encodedData);
    }

    function testfail_validateProtectionData_ShouldFailIfNumberOfTranchesIsTooHigh() public {
        uint32[] memory trancheAmountFractionInMillionth = new uint32[](4);
        uint32[] memory trancheFeeRateInMillionth = new uint32[](4);
        trancheAmountFractionInMillionth[0] = 300000;
        trancheAmountFractionInMillionth[1] = 300000;
        trancheAmountFractionInMillionth[2] = 400000;
        trancheFeeRateInMillionth[0] = 3000;
        trancheFeeRateInMillionth[1] = 3000;
        trancheFeeRateInMillionth[2] = 4000;
        ProtectionData memory protectionData = ProtectionData({
            endTime: 10000,
            numberOfTranches: 4,
            rightsEncoding: 1,
            ltvProtectClaims: 7500,
            ltvProtectForeclosure: 7500,
            openingFeeRate: 6000,
            cancellationFeeRate: 6000,
            trancheAmountFractionInMillionth: trancheAmountFractionInMillionth,
            trancheFeeRateInMillionth: trancheFeeRateInMillionth
        });
        uint256 encodedData = ProtectionLibV1._encodeProtectionData(protectionData);
        bytes memory encodedError = abi.encodeWithSelector(Errors.NumberOfProtectionClaimsTooHigh.selector);
        vm.expectRevert(encodedError);
        ProtectionLibV1.validateEncodedProtection(encodedData);
    }

    function testfail_validateProtectionData_ShouldFailIfLtvProtectClaimsIsHigherThanAMillon() public {
        uint32[] memory trancheAmountFractionInMillionth = new uint32[](3);
        uint32[] memory trancheFeeRateInMillionth = new uint32[](3);
        trancheAmountFractionInMillionth[0] = 300000;
        trancheAmountFractionInMillionth[1] = 300000;
        trancheAmountFractionInMillionth[2] = 400000;
        trancheFeeRateInMillionth[0] = 3000;
        trancheFeeRateInMillionth[1] = 3000;
        trancheFeeRateInMillionth[2] = 4000;
        ProtectionData memory protectionData = ProtectionData({
            endTime: 10000,
            numberOfTranches: 3,
            rightsEncoding: 1,
            ltvProtectClaims: 1000005,
            ltvProtectForeclosure: 7500,
            openingFeeRate: 6000,
            cancellationFeeRate: 6000,
            trancheAmountFractionInMillionth: trancheAmountFractionInMillionth,
            trancheFeeRateInMillionth: trancheFeeRateInMillionth
        });
        uint256 encodedData = ProtectionLibV1._encodeProtectionData(protectionData);
        bytes memory encodedError = abi.encodeWithSelector(Errors.FractionExceedsUnityInMillionth.selector);
        vm.expectRevert(encodedError);
        ProtectionLibV1.validateEncodedProtection(encodedData);
    }

    function testfail_validateProtectionData_ShouldFailIfLtvProtectForeclosureIsHigherThanAMillon() public {
        uint32[] memory trancheAmountFractionInMillionth = new uint32[](3);
        uint32[] memory trancheFeeRateInMillionth = new uint32[](3);
        trancheAmountFractionInMillionth[0] = 300000;
        trancheAmountFractionInMillionth[1] = 300000;
        trancheAmountFractionInMillionth[2] = 400000;
        trancheFeeRateInMillionth[0] = 3000;
        trancheFeeRateInMillionth[1] = 3000;
        trancheFeeRateInMillionth[2] = 4000;
        ProtectionData memory protectionData = ProtectionData({
            endTime: 10000,
            numberOfTranches: 3,
            rightsEncoding: 1,
            ltvProtectClaims: 7500,
            ltvProtectForeclosure: 1000005,
            openingFeeRate: 6000,
            cancellationFeeRate: 6000,
            trancheAmountFractionInMillionth: trancheAmountFractionInMillionth,
            trancheFeeRateInMillionth: trancheFeeRateInMillionth
        });
        uint256 encodedData = ProtectionLibV1._encodeProtectionData(protectionData);
        bytes memory encodedError = abi.encodeWithSelector(Errors.FractionExceedsUnityInMillionth.selector);
        vm.expectRevert(encodedError);
        ProtectionLibV1.validateEncodedProtection(encodedData);
    }

    function testfail_validateProtectionData_ShouldFailIfOpeningFeeRateIsHigherThanAMillon() public {
        uint32[] memory trancheAmountFractionInMillionth = new uint32[](3);
        uint32[] memory trancheFeeRateInMillionth = new uint32[](3);
        trancheAmountFractionInMillionth[0] = 300000;
        trancheAmountFractionInMillionth[1] = 300000;
        trancheAmountFractionInMillionth[2] = 400000;
        trancheFeeRateInMillionth[0] = 3000;
        trancheFeeRateInMillionth[1] = 3000;
        trancheFeeRateInMillionth[2] = 4000;
        ProtectionData memory protectionData = ProtectionData({
            endTime: 10000,
            numberOfTranches: 3,
            rightsEncoding: 1,
            ltvProtectClaims: 7500,
            ltvProtectForeclosure: 7500,
            openingFeeRate: 1000005,
            cancellationFeeRate: 6000,
            trancheAmountFractionInMillionth: trancheAmountFractionInMillionth,
            trancheFeeRateInMillionth: trancheFeeRateInMillionth
        });
        uint256 encodedData = ProtectionLibV1._encodeProtectionData(protectionData);
        bytes memory encodedError = abi.encodeWithSelector(Errors.FractionExceedsUnityInMillionth.selector);
        vm.expectRevert(encodedError);
        ProtectionLibV1.validateEncodedProtection(encodedData);
    }

    function testfail_validateProtectionData_ShouldFailIfCancellationgFeeRateIsHigherThanAMillon() public {
        uint32[] memory trancheAmountFractionInMillionth = new uint32[](3);
        uint32[] memory trancheFeeRateInMillionth = new uint32[](3);
        trancheAmountFractionInMillionth[0] = 300000;
        trancheAmountFractionInMillionth[1] = 300000;
        trancheAmountFractionInMillionth[2] = 400000;
        trancheFeeRateInMillionth[0] = 3000;
        trancheFeeRateInMillionth[1] = 3000;
        trancheFeeRateInMillionth[2] = 4000;
        ProtectionData memory protectionData = ProtectionData({
            endTime: 10000,
            numberOfTranches: 3,
            rightsEncoding: 1,
            ltvProtectClaims: 7500,
            ltvProtectForeclosure: 7500,
            openingFeeRate: 6000,
            cancellationFeeRate: 1000005,
            trancheAmountFractionInMillionth: trancheAmountFractionInMillionth,
            trancheFeeRateInMillionth: trancheFeeRateInMillionth
        });
        uint256 encodedData = ProtectionLibV1._encodeProtectionData(protectionData);
        bytes memory encodedError = abi.encodeWithSelector(Errors.FractionExceedsUnityInMillionth.selector);
        vm.expectRevert(encodedError);
        ProtectionLibV1.validateEncodedProtection(encodedData);
    }

    function testfail_validateProtectionData_ShouldFailIfTranche1IsHigherThanAMillon() public {
        uint32[] memory trancheAmountFractionInMillionth = new uint32[](3);
        uint32[] memory trancheFeeRateInMillionth = new uint32[](3);
        trancheAmountFractionInMillionth[0] = 300000;
        trancheAmountFractionInMillionth[1] = 300000;
        trancheAmountFractionInMillionth[2] = 400000;
        trancheFeeRateInMillionth[0] = 1000005;
        trancheFeeRateInMillionth[1] = 3000;
        trancheFeeRateInMillionth[2] = 4000;
        ProtectionData memory protectionData = ProtectionData({
            endTime: 10000,
            numberOfTranches: 3,
            rightsEncoding: 1,
            ltvProtectClaims: 7500,
            ltvProtectForeclosure: 7500,
            openingFeeRate: 6000,
            cancellationFeeRate: 6000,
            trancheAmountFractionInMillionth: trancheAmountFractionInMillionth,
            trancheFeeRateInMillionth: trancheFeeRateInMillionth
        });
        uint256 encodedData = ProtectionLibV1._encodeProtectionData(protectionData);
        bytes memory encodedError = abi.encodeWithSelector(Errors.FractionExceedsUnityInMillionth.selector);
        vm.expectRevert(encodedError);
        ProtectionLibV1.validateEncodedProtection(encodedData);
    }

    function testfail_validateProtectionData_ShouldFailIfTranche2IsHigherThanAMillon() public {
        uint32[] memory trancheAmountFractionInMillionth = new uint32[](3);
        uint32[] memory trancheFeeRateInMillionth = new uint32[](3);
        trancheAmountFractionInMillionth[0] = 300000;
        trancheAmountFractionInMillionth[1] = 300000;
        trancheAmountFractionInMillionth[2] = 400000;
        trancheFeeRateInMillionth[0] = 3000;
        trancheFeeRateInMillionth[1] = 1000005;
        trancheFeeRateInMillionth[2] = 4000;
        ProtectionData memory protectionData = ProtectionData({
            endTime: 10000,
            numberOfTranches: 3,
            rightsEncoding: 1,
            ltvProtectClaims: 7500,
            ltvProtectForeclosure: 7500,
            openingFeeRate: 6000,
            cancellationFeeRate: 6000,
            trancheAmountFractionInMillionth: trancheAmountFractionInMillionth,
            trancheFeeRateInMillionth: trancheFeeRateInMillionth
        });
        uint256 encodedData = ProtectionLibV1._encodeProtectionData(protectionData);
        bytes memory encodedError = abi.encodeWithSelector(Errors.FractionExceedsUnityInMillionth.selector);
        vm.expectRevert(encodedError);
        ProtectionLibV1.validateEncodedProtection(encodedData);
    }

    function testfail_validateProtectionData_ShouldFailIfTranche3IsHigherThanAMillon() public {
        uint32[] memory trancheAmountFractionInMillionth = new uint32[](3);
        uint32[] memory trancheFeeRateInMillionth = new uint32[](3);
        trancheAmountFractionInMillionth[0] = 300000;
        trancheAmountFractionInMillionth[1] = 300000;
        trancheAmountFractionInMillionth[2] = 400000;
        trancheFeeRateInMillionth[0] = 3000;
        trancheFeeRateInMillionth[1] = 3000;
        trancheFeeRateInMillionth[2] = 1000005;
        ProtectionData memory protectionData = ProtectionData({
            endTime: 10000,
            numberOfTranches: 3,
            rightsEncoding: 1,
            ltvProtectClaims: 7500,
            ltvProtectForeclosure: 7500,
            openingFeeRate: 6000,
            cancellationFeeRate: 6000,
            trancheAmountFractionInMillionth: trancheAmountFractionInMillionth,
            trancheFeeRateInMillionth: trancheFeeRateInMillionth
        });
        uint256 encodedData = ProtectionLibV1._encodeProtectionData(protectionData);
        bytes memory encodedError = abi.encodeWithSelector(Errors.FractionExceedsUnityInMillionth.selector);
        vm.expectRevert(encodedError);
        ProtectionLibV1.validateEncodedProtection(encodedData);
    }

    function testfail_validateProtectionData_ShouldFailIfTranche1FeeIsHigherThanAMillon() public {
        uint32[] memory trancheAmountFractionInMillionth = new uint32[](3);
        uint32[] memory trancheFeeRateInMillionth = new uint32[](3);
        trancheAmountFractionInMillionth[0] = 1000005;
        trancheAmountFractionInMillionth[1] = 300000;
        trancheAmountFractionInMillionth[2] = 400000;
        trancheFeeRateInMillionth[0] = 3000;
        trancheFeeRateInMillionth[1] = 3000;
        trancheFeeRateInMillionth[2] = 4000;
        ProtectionData memory protectionData = ProtectionData({
            endTime: 10000,
            numberOfTranches: 3,
            rightsEncoding: 1,
            ltvProtectClaims: 7500,
            ltvProtectForeclosure: 7500,
            openingFeeRate: 6000,
            cancellationFeeRate: 6000,
            trancheAmountFractionInMillionth: trancheAmountFractionInMillionth,
            trancheFeeRateInMillionth: trancheFeeRateInMillionth
        });
        uint256 encodedData = ProtectionLibV1._encodeProtectionData(protectionData);
        bytes memory encodedError = abi.encodeWithSelector(Errors.FractionExceedsUnityInMillionth.selector);
        vm.expectRevert(encodedError);
        ProtectionLibV1.validateEncodedProtection(encodedData);
    }

    function testfail_validateProtectionData_ShouldFailIfTranche2FeeIsHigherThanAMillon() public {
        uint32[] memory trancheAmountFractionInMillionth = new uint32[](3);
        uint32[] memory trancheFeeRateInMillionth = new uint32[](3);
        trancheAmountFractionInMillionth[0] = 300000;
        trancheAmountFractionInMillionth[1] = 1000005;
        trancheAmountFractionInMillionth[2] = 400000;
        trancheFeeRateInMillionth[0] = 3000;
        trancheFeeRateInMillionth[1] = 3000;
        trancheFeeRateInMillionth[2] = 4000;
        ProtectionData memory protectionData = ProtectionData({
            endTime: 10000,
            numberOfTranches: 3,
            rightsEncoding: 1,
            ltvProtectClaims: 7500,
            ltvProtectForeclosure: 7500,
            openingFeeRate: 6000,
            cancellationFeeRate: 6000,
            trancheAmountFractionInMillionth: trancheAmountFractionInMillionth,
            trancheFeeRateInMillionth: trancheFeeRateInMillionth
        });
        uint256 encodedData = ProtectionLibV1._encodeProtectionData(protectionData);
        bytes memory encodedError = abi.encodeWithSelector(Errors.FractionExceedsUnityInMillionth.selector);
        vm.expectRevert(encodedError);
        ProtectionLibV1.validateEncodedProtection(encodedData);
    }

    function testfail_validateProtectionData_ShouldFailIfTrancheFee3IsHigherThanAMillon() public {
        uint32[] memory trancheAmountFractionInMillionth = new uint32[](3);
        uint32[] memory trancheFeeRateInMillionth = new uint32[](3);
        trancheAmountFractionInMillionth[0] = 300000;
        trancheAmountFractionInMillionth[1] = 300000;
        trancheAmountFractionInMillionth[2] = 1000005;
        trancheFeeRateInMillionth[0] = 3000;
        trancheFeeRateInMillionth[1] = 3000;
        trancheFeeRateInMillionth[2] = 4000;
        ProtectionData memory protectionData = ProtectionData({
            endTime: 10000,
            numberOfTranches: 3,
            rightsEncoding: 1,
            ltvProtectClaims: 7500,
            ltvProtectForeclosure: 7500,
            openingFeeRate: 6000,
            cancellationFeeRate: 6000,
            trancheAmountFractionInMillionth: trancheAmountFractionInMillionth,
            trancheFeeRateInMillionth: trancheFeeRateInMillionth
        });
        uint256 encodedData = ProtectionLibV1._encodeProtectionData(protectionData);
        bytes memory encodedError = abi.encodeWithSelector(Errors.FractionExceedsUnityInMillionth.selector);
        vm.expectRevert(encodedError);
        ProtectionLibV1.validateEncodedProtection(encodedData);
    }
}
