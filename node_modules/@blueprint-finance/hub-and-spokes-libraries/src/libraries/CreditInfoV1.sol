// SPDX-License-Identifier: AGPL-3.0
pragma solidity ^0.8.24;

import {Math} from "@openzeppelin/contracts/utils/math/Math.sol";

import {WAD, TEMP_UNIT} from "../utils/Constants.sol";
import {Errors} from "./Errors.sol";
import {CompactEncodeLib} from "./CompactEncodeLib.sol";

///@title CreditInfo library V1 to handle credit information
///@author Leonhard Horstmeyer
///@notice Library to handle credit information
library CreditInfoV1 {
    using Math for uint256;

    // COMPUTE FUNCTIONS //////////////////////////////////////

    ///@notice Compute the new user borrow fraction in WAD
    ///@param oldUserBorrowFractionInWad The old user borrow fraction in WAD
    ///@param totalBorrowedInToken The total borrowed amount in token
    ///@param amountInToken The amount in token
    ///@param isRepayment The flag to indicate if it is a repayment or a payment
    ///@param byUser The flag to indicate if it is done by the user
    ///@return The new user borrow fraction in WAD
    function computeNewUserBorrowFractionInWad(
        uint256 oldUserBorrowFractionInWad,
        uint256 totalBorrowedInToken,
        uint256 amountInToken,
        bool isRepayment,
        bool byUser
    ) internal pure returns (uint256) {
        return _computeNewFractionInWad(
            oldUserBorrowFractionInWad, totalBorrowedInToken, amountInToken, isRepayment, byUser
        );
    }

    ///@notice Compute the new user borrow fraction from the credit info in WAD
    ///@param creditInfo The credit info
    ///@param totalBorrowedInToken The total borrowed amount in token
    ///@param amountInToken The amount in token
    ///@param isRepayment The flag to indicate if it is a repayment or a borrow
    ///@param byUser The flag to indicate if it is done by the user
    ///@return The new user borrow fraction in WAD
    function computeNewUserBorrowFractionFromInfoInWad(
        uint256 creditInfo,
        uint256 totalBorrowedInToken,
        uint256 amountInToken,
        bool isRepayment,
        bool byUser
    ) internal pure returns (uint256) {
        return _computeNewFractionInWad(
            decodeUserBorrowFraction(creditInfo), totalBorrowedInToken, amountInToken, isRepayment, byUser
        );
    }

    ///@notice Compute the new fraction in WAD based on the old fraction, total amount and amount
    ///@param oldUserSupplyFractionInWad The old user supply fraction in WAD
    ///@param totalSuppliedInToken The total supplied amount in token
    ///@param amountInToken The amount in token
    ///@param isWithdrawal The flag to indicate if it is a withdrawal or a supply
    ///@param byUser The flag to indicate if it is done by the user
    ///@return The new user supply fraction in WAD
    function computeNewUserSupplyFractionInWad(
        uint256 oldUserSupplyFractionInWad,
        uint256 totalSuppliedInToken,
        uint256 amountInToken,
        bool isWithdrawal,
        bool byUser
    ) internal pure returns (uint256) {
        return _computeNewFractionInWad(
            oldUserSupplyFractionInWad, totalSuppliedInToken, amountInToken, isWithdrawal, byUser
        );
    }

    ///@notice Compute the new user supply fraction from the credit info in WAD
    ///@param creditInfo The credit info
    ///@param totalSuppliedInToken The total supplied amount in token
    ///@param amountInToken The amount in token
    ///@param isWithdrawal The flag to indicate if it is a withdrawal or a supply
    ///@param byUser The flag to indicate if it is done by the user
    ///@return The new user supply fraction in WAD
    function computeNewUserSupplyFractionFromInfoInWad(
        uint256 creditInfo,
        uint256 totalSuppliedInToken,
        uint256 amountInToken,
        bool isWithdrawal,
        bool byUser
    ) internal pure returns (uint256) {
        return _computeNewFractionInWad(
            decodeUserSupplyFraction(creditInfo), totalSuppliedInToken, amountInToken, isWithdrawal, byUser
        );
    }

    // UPDATE FUNCTIONS //////////////////////////////////////

    // Function to update the credit with new values for base and token amounts
    ///@param originalValue The original credit value
    ///@param amountInBase The amount in base
    ///@param amountInToken The amount in token
    ///@return The updated credit value
    function updateCredit(uint256 originalValue, uint256 amountInBase, uint256 amountInToken)
        internal
        pure
        returns (uint256)
    {
        // Encode amountInBase and amountInToken using encode_uint64
        (uint64 baseSignificand, uint8 baseExponent) = CompactEncodeLib.encode_uint64(amountInBase);
        (uint64 tokenSignificand, uint8 tokenExponent) = CompactEncodeLib.encode_uint64(amountInToken);

        // Clear the relevant bits in the originalValue and set them to the new values
        uint256 mask = uint256(type(uint144).max);
        uint256 updatedValue = (
            (originalValue & ~mask)
                | (
                    (
                        (uint256(baseSignificand) << (64 + 16)) | (uint256(baseExponent) << 64 + 8)
                            | (uint256(tokenSignificand) << 8) | (uint256(tokenExponent))
                    ) & mask
                )
        );

        return updatedValue;
    }

    // Function to update the user borrow fraction
    ///@param originalValue The original credit value
    ///@param newValueInWad The new value in WAD
    ///@return The updated credit value
    function updateUserBorrowFraction(uint256 originalValue, uint256 newValueInWad) internal pure returns (uint256) {
        return _updateFractionAtPosition(originalValue, newValueInWad, 144);
    }

    // Function to update the user supply fraction
    ///@param originalValue The original credit value
    ///@param newValueInWad The new value in WAD
    ///@return The updated credit value
    function updateUserSupplyFraction(uint256 originalValue, uint256 newValueInWad) internal pure returns (uint256) {
        return _updateFractionAtPosition(originalValue, newValueInWad, 200);
    }

    // DECODE FUNCTIONS //////////////////////////////////////

    // Function to decode the credit and return amountInBase and amountInToken
    ///@notice Decode the credit and return the amount in base and token
    ///@param encodedValue The encoded value
    ///@return amountInBase amount in base
    ///@return amountInToken amount in token
    function decodeCreditAmount(uint256 encodedValue)
        internal
        pure
        returns (uint256 amountInBase, uint256 amountInToken)
    {
        // Extract the values from the encodedValue
        uint64 baseSignificand = uint64(encodedValue >> (64 + 16));
        uint8 baseExponent = uint8(encodedValue >> 64 + 8);
        uint64 tokenSignificand = uint64(encodedValue >> 8);
        uint8 tokenExponent = uint8(encodedValue);

        // Decode the values using decode_uint64
        amountInBase = CompactEncodeLib.decode_uint64(baseSignificand, baseExponent);
        amountInToken = CompactEncodeLib.decode_uint64(tokenSignificand, tokenExponent);
    }

    // Function to decode the user borrow fraction
    ///@notice Decode the user borrow fraction from the encoded value
    ///@param encodedValue The encoded value
    ///@return The user borrow fraction
    function decodeUserBorrowFraction(uint256 encodedValue) internal pure returns (uint256) {
        // Extract the user borrow fraction from the encodedValue
        return uint256(uint56(encodedValue >> 144)).mulDiv(WAD, TEMP_UNIT);
    }

    // Function to decode the user supply fraction
    ///@notice Decode the user supply fraction from the encoded value
    ///@param encodedValue The encoded value
    ///@return The user supply fraction
    function decodeUserSupplyFraction(uint256 encodedValue) internal pure returns (uint256) {
        // Extract the user supply fraction from the encodedValue
        return uint256(uint56(encodedValue >> 200)).mulDiv(WAD, TEMP_UNIT);
    }

    // HELPER FUNCTIONS //////////////////////////////////////

    // Function to compute the new fraction in WAD
    ///@notice Compute the new fraction in WAD based on the old fraction, total amount and amount
    ///@param f The old fraction
    ///@param x The total amount
    ///@param y The amount in question
    ///@param flag1 The flag to indicate if it is a withdrawal or a supply
    ///@param flag2 The flag to indicate if it is done by the user or on behalf of user by protocol
    function _computeNewFractionInWad(uint256 f, uint256 x, uint256 y, bool flag1, bool flag2)
        private
        pure
        returns (uint256)
    {
        uint256 xFraction;

        if (flag2) {
            if (f == WAD) return WAD;

            xFraction = x.mulDiv(f, WAD);

            if (flag1) {
                if (y > xFraction) {
                    revert Errors.RepaymentExceedsUserBorrowedAmount();
                }
                return (xFraction - y).mulDiv(WAD, x - y);
            } else {
                return (xFraction + y).mulDiv(WAD, x + y);
            }
        } else {
            xFraction = x.mulDiv(WAD - f, WAD);

            if (flag1) {
                if (y > xFraction) {
                    revert Errors.RepaymentExceedsConcreteBorrowedAmount();
                }
                return WAD - (xFraction - y).mulDiv(WAD, x - y);
            } else {
                return WAD - (xFraction + y).mulDiv(WAD, x + y);
            }
        }
    }

    // Function to update the user supply fraction
    function _updateFractionAtPosition(uint256 originalValue, uint256 newValueInWad, uint8 position)
        private
        pure
        returns (uint256)
    {
        // loose of precision.
        uint256 newValueInTempUnit = newValueInWad.mulDiv(TEMP_UNIT, WAD);
        uint256 maxValueInTempUnit = type(uint56).max;

        // NOTE: So now we can go up to values MaxValueInTempUnit/TEMP_UNIT which is 720,575940379 and approximately 72057%. So allows for quite a high fraction.
        // NOTE: We cap the price to 72057% of the total supplied amount instead of reverting, because this is just a book-keeping value and should not revert a call coming from the protocol.
        uint56 newValue =
            newValueInTempUnit > maxValueInTempUnit ? uint56(maxValueInTempUnit) : uint56(newValueInTempUnit);

        // Shift newValue left by 128 + 16 + 56 bits
        // return _updateUint56ValueAtPosition(originalValue, newValue, 144 + 56);
        uint256 mask = ((uint256(type(uint56).max)) << position);
        // Clear the relevant bits in the originalValue and set them to the new

        return (originalValue & ~mask) | ((uint256(newValue) << position) & mask);
    }
}
