// SPDX-License-Identifier: AGPL-3.0
pragma solidity ^0.8.24;

import {Errors} from "./Errors.sol";

library AddressLib {
    // ALL ADDRESS ENCODING AND DECODING //////////////////////////////////////

    // Retrieve the encoded token address from the bytes32 value
    ///@notice Retrieve the encoded token address from the bytes32 value
    ///@param encoded The bytes32 value to decode
    ///@return address The address of the token
    function getAddress(bytes32 encoded) internal pure returns (address) {
        return address(uint160(uint256(encoded)));
    }

    // TOKEN PLUS DENOMIATION ENCODING AND DECODING ////////////////////////////

    // Encode the token address and denomination into a bytes32 value
    ///@notice Encode the token address and denomination into a bytes32 value
    ///@param token The address of the token
    ///@param denomination The denomination of the token
    ///@return tokenData The bytes32 value of the token and denomination
    function encodeToken(address token, uint96 denomination) internal pure returns (bytes32 tokenData) {
        tokenData = bytes32((uint256(denomination) << 160) | uint256(uint160(token)));
    }

    // Retrieve the encoded token denomination from the bytes32 value
    ///@notice Retrieve the encoded token denomination from the bytes32 value
    ///@param tokenData The bytes32 value to decode
    ///@return denomination The denomination of the token
    function getDenomination(bytes32 tokenData) internal pure returns (uint256) {
        return uint256(tokenData >> 160);
    }

    // Retrieve the encoded token address and denomination from the bytes32 value
    ///@notice Retrieve the encoded token address and denomination from the bytes32 value
    ///@param tokenData The bytes32 value to decode
    ///@return token The address of the token
    ///@return denomination The denomination of the token
    function getAddressAndDenom(bytes32 tokenData) internal pure returns (address token, uint256 denomination) {
        token = getAddress(tokenData);
        denomination = getDenomination(tokenData);
    }

    // ENCODE ADDRESS, DECIMALS AND FLAGS //////////////

    ///@notice Encode the address and decimals into a bytes32 value
    ///@param addr The address of the token
    ///@param decimals The decimals of the token
    ///@return The uint256 value of the address and decimals
    function encodeAddressDecimalsAndFlag(address addr, uint8 decimals, uint8 flag) internal pure returns (uint256) {
        return (uint256(flag) << 248) | (uint256(decimals) << 160) | uint256(uint160(addr));
    }

    ///@notice Retrieve the encoded decimals from the bytes32 value
    ///@param addressDecimalsData The bytes32 value to decode
    ///@return The decimals of the token
    function getDecimals(uint256 addressDecimalsData) internal pure returns (uint8) {
        return uint8(addressDecimalsData >> 160);
    }

    ///@notice Retrieve the encoded flag from the bytes32 value
    ///@param addressDecimalsData The bytes32 value to decode
    ///@return The flag of the token
    function getFlag(uint256 addressDecimalsData) internal pure returns (uint8) {
        return uint8(addressDecimalsData >> 248);
    }

    ///@notice Retrieve the encoded address and decimals from the bytes32 value
    ///@param addressDecimalsData The bytes32 value to decode
    ///@return The address of the token
    ///@return The decimals of the token
    function getAddressAndDecimals(uint256 addressDecimalsData) internal pure returns (address, uint8) {
        return (getAddress(addressDecimalsData), getDecimals(addressDecimalsData));
    }

    // ENCODE AND DECODE ADDRESS AND EID //////////////////////////////////////

    ///@notice Encode the address and EID into a bytes32 value
    ///@param addr The address of the token
    ///@param eid The EID of the token
    ///@return The bytes32 value of the address and EID
    function encodeAddressAndEid(address addr, uint32 eid) internal pure returns (bytes32) {
        return bytes32((uint256(eid) << 160) | uint256(uint160(addr)));
    }

    ///@notice Retrieve the encoded EID from the bytes32 value
    ///@param addressEidData The bytes32 value to decode
    ///@return The EID of the token
    function getEid(bytes32 addressEidData) internal pure returns (uint32) {
        return uint32(uint256(addressEidData) >> 160);
    }

    ///@notice Retrieve the encoded address and EID from the bytes32 value
    ///@param addressEidData The bytes32 value to decode
    ///@return The address of the token
    ///@return The EID of the token
    function getAddressAndEid(bytes32 addressEidData) internal pure returns (address, uint32) {
        return (getAddress(addressEidData), getEid(addressEidData));
    }

    // ENCODE ADDRESS AND MAX 96 BIT NUMBER ///////////////////////////////////

    ///@notice Encode the address and a number into a bytes32 value
    ///@param addr The address of the token
    ///@param number The number to encode
    ///@return The bytes32 value of the address and number
    function encodeAddressAndMax96BitNumber(address addr, uint256 number) internal pure returns (bytes32) {
        if (number > type(uint96).max) revert Errors.ExceedsUint96MaxPrecission();
        return bytes32((number << 160) | uint256(uint160(addr)));
    }

    ///@notice Retrieve the encoded number from the bytes32 value
    ///@param addressNumberData The bytes32 value to decode
    ///@return The number
    function getMax96BitNumber(bytes32 addressNumberData) internal pure returns (uint256) {
        return uint256(addressNumberData >> 160);
    }

    ///@notice Retrieve the encoded address and number from the bytes32 value
    ///@param addressNumberData The bytes32 value to decode
    ///@return The address of the token
    ///@return The number
    function getAddressAndMax96BitNumber(bytes32 addressNumberData) internal pure returns (address, uint256) {
        return (getAddress(addressNumberData), getMax96BitNumber(addressNumberData));
    }

    // LOAN ID ENCODING AND DECODING ///////////////////////////////////////////

    ///@notice Encode the loan ID into a bytes32 value
    ///@param blueprint The address of the token
    ///@param chainId The chain ID of the token
    ///@param index The index of the token
    function encodeLoanIdToBytes32(address blueprint, uint32 chainId, uint64 index)
        internal
        pure
        returns (bytes32 loanIdInBytes32)
    {
        loanIdInBytes32 = bytes32(encodeLoanId(blueprint, chainId, index));
    }

    ///@notice Encode the loan ID into a uint256 value
    ///@param blueprint The address of the token
    ///@param chainId The chain ID of the token
    ///@param index The index of the token
    function encodeLoanId(address blueprint, uint32 chainId, uint64 index) internal pure returns (uint256 loanId) {
        loanId = (uint256(index) << 192) | (uint256(chainId) << 160) | uint256(uint160(blueprint));
    }

    // Retrieve the encoded token address from the uint256 value
    ///@notice Retrieve the encoded token address from the uint256 value
    ///@param encoded The uint256 value to decode
    ///@return address The address of the token
    function getAddress(uint256 encoded) internal pure returns (address) {
        return address(uint160(encoded));
    }

    // the chain Id will be the 8 bytes after shifting the tokenData by 160 bits
    ///@notice Retrieve the encoded chain ID from the uint256 value
    ///@param loanId The uint256 value to decode
    ///@return chainId The chain ID of the token
    function decodeChainId(uint256 loanId) internal pure returns (uint32) {
        return uint32(loanId >> 160);
    }

    // the first four bytes of the chainId will be an index
    ///@notice Retrieve the encoded index from the uint256 value
    ///@param loanId The uint256 value to decode
    ///@return index The index of the token
    function decodeImplementation(uint256 loanId) internal pure returns (uint64) {
        return uint64(loanId >> 192);
    }

    /**
     * @dev Converts an address into a bytes32, left-padded with zeros.
     * @param addr The address to convert.
     * @return result The bytes32 representation of the address.
     */
    function addressToBytes32(address addr) internal pure returns (bytes32 result) {
        assembly {
            result := addr
        }
    }

    /**
     * @dev Converts a bytes32 into an address, assuming it is left-padded with zeros.
     * @param b32 The bytes32 to convert.
     * @return addr The address representation of the bytes32.
     */
    function bytes32ToAddress(bytes32 b32) internal pure returns (address addr) {
        assembly {
            addr := b32
        }
    }
}
