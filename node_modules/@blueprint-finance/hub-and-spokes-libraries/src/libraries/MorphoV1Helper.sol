// SPDX-License-Identifier: AGPL-3.0
pragma solidity 0.8.24;

import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {IERC20Metadata} from "@openzeppelin/contracts/token/ERC20/extensions/IERC20Metadata.sol";
import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import {Math} from "@openzeppelin/contracts/utils/math/Math.sol";
import {SafeCast} from "@openzeppelin/contracts/utils/math/SafeCast.sol";
import {Id, IMorpho, MarketParams} from "@morpho-org/morpho-blue/src/interfaces/IMorpho.sol";
import {IOracle} from "@morpho-org/morpho-blue/src/interfaces/IOracle.sol";

import {Errors} from "./Errors.sol";
import {TokenHelper} from "./TokenHelper.sol";
import {AddressLib} from "./AddressLib.sol";
import {MorphoBalancesLib} from "@morpho-org/morpho-blue/src/libraries/periphery/MorphoBalancesLib.sol";
import {MorphoStorageLib} from "@morpho-org/morpho-blue/src/libraries/periphery/MorphoStorageLib.sol";
import {WAD} from "../utils/Constants.sol";

interface IClaimMorphoRewards {
    event ClaimedRewards(address token, uint256 amount);

    function claim(address account, address reward, uint256 claimable, bytes32[] memory proof)
        external
        returns (uint256 amount);
}

library MorphoV1Helper {
    using Math for uint256;
    using SafeERC20 for IERC20;

    // PRICE HANDLING AND ///////////////////////////////

    function getLatestTokenInTokenPrice(
        address oracle,
        uint8 quoteDecimals,
        bytes32 collateralTokenInfo,
        bytes32 borrowTokenInfo,
        uint256 denominationStandardUnit,
        uint256 denominationSmallestUnit,
        bool inStandardUnit
    ) internal view returns (uint256 price, uint256 denomination) {
        // the raw price for Morpho is in terms of the smallest units (not in standard units)!
        uint256 rawPrice = IOracle(oracle).price();
        if (inStandardUnit) {
            denomination = denominationStandardUnit;
            price = rawPrice.mulDiv(
                AddressLib.getDenomination(collateralTokenInfo), AddressLib.getDenomination(borrowTokenInfo)
            ).mulDiv(denomination, 10 ** quoteDecimals);
        } else {
            denomination = denominationSmallestUnit;
            price = rawPrice.mulDiv(denomination, 10 ** quoteDecimals);
        }
    }

    function getLatestTokenInTokenPrice(
        uint256 oracleInfo,
        bytes32 collateralTokenInfo,
        bytes32 borrowTokenInfo,
        uint256 denominationStandardUnit,
        uint256 denominationSmallestUnit,
        bool inStandardUnit
    ) public view returns (uint256 price, uint256 denomination) {
        (address oracle, uint8 quoteDecimals) = AddressLib.getAddressAndDecimals(oracleInfo);

        return getLatestTokenInTokenPrice(
            oracle,
            quoteDecimals,
            collateralTokenInfo,
            borrowTokenInfo,
            denominationStandardUnit,
            denominationSmallestUnit,
            inStandardUnit
        );
    }

    function getLenderSupplied(IMorpho morpho, Id marketId) internal view returns (uint256 amount) {
        bytes32[] memory slots = new bytes32[](1);
        slots[0] = MorphoStorageLib.positionBorrowSharesAndCollateralSlot(marketId, address(this));
        bytes32[] memory values = morpho.extSloads(slots);
        amount = uint256(values[0] >> 128);
    }

    function getLenderDebt(IMorpho morpho, MarketParams memory marketParams) internal view returns (uint256 amount) {
        amount = MorphoBalancesLib.expectedBorrowAssets(morpho, marketParams, address(this));
    }

    function getCurrentLtvInWad(
        IMorpho morpho,
        MarketParams memory marketParams,
        Id marketId,
        uint256 oracleInfo,
        bytes32 collateralTokenInfo,
        bytes32 borrowTokenInfo,
        uint256 denominationStandardUnit,
        uint256 denominationSmallestUnit
    ) public view returns (uint256 ltv) {
        uint256 collateralBalanceInToken = getLenderSupplied(morpho, marketId);
        if (collateralBalanceInToken == 0) {
            return 0;
        }
        uint256 borrowBalanceInToken = getLenderDebt(morpho, marketParams);
        (uint256 collateralPriceInBorrowTokens, uint256 quoteDenomination) = getLatestTokenInTokenPrice(
            oracleInfo, collateralTokenInfo, borrowTokenInfo, denominationStandardUnit, denominationSmallestUnit, false
        );
        // return borrowBalance.mulDiv(WAD, collateralBalanceInBorrowTokens);
        ltv = borrowBalanceInToken.mulDiv(
            WAD, collateralBalanceInToken.mulDiv(collateralPriceInBorrowTokens, quoteDenomination)
        );
    }

    function encodeTokenInfo(address token_) public view returns (bytes32 tokenInfo_) {
        uint96 denomination_ = SafeCast.toUint96(10 ** IERC20Metadata(token_).decimals());
        return AddressLib.encodeToken(token_, denomination_);
    }

    function assetValidation(
        bytes32 collateralTokenInfo,
        address collateralAsset,
        bytes32 borrowTokenInfo,
        address borrowedAsset
    ) public pure {
        if (AddressLib.getAddress(collateralTokenInfo) != collateralAsset) revert Errors.AssetDivergence();
        if (borrowedAsset != address(0)) {
            if (AddressLib.getAddress(borrowTokenInfo) != borrowedAsset) revert Errors.AssetDivergence();
        }
    }

    // REWARD HANDLING //////////////////////////////////

    ///@notice Decodes encoded proof data into URD and txData arrays
    ///@param proofs Encoded proof data
    ///@return urd Array of URD addresses
    ///@return txData Array of transaction data
    function decodeMorphoV1Proofs(bytes memory proofs)
        internal
        pure
        returns (address[] memory urd, bytes[] memory txData)
    {
        // abi.decode(proofs, (address[], bytes[]));
        if (proofs.length != 0) {
            (urd, txData) = abi.decode(proofs, (address[], bytes[]));
        }
    }

    ///@notice Encodes URD and txData arrays into proof data
    ///@param urd Array of URD addresses
    ///@param txData Array of transaction data
    ///@return proofs Encoded proof data
    function encodeMorphoV1Proofs(address[] memory urd, bytes[] memory txData)
        internal
        pure
        returns (bytes memory proofs)
    {
        // abi.encode(urd, data);
        proofs = abi.encode(urd, txData);
    }

    ///@notice Decodes transaction data into account, token, and claimable amount
    ///@param txData Encoded transaction data
    ///@return account Account address
    ///@return token Token address
    ///@return claimable Claimable amount
    function decodeTransactionData(bytes memory txData)
        internal
        pure
        returns (address account, address token, uint256 claimable)
    {
        // Skip the first 4 bytes (function selector)
        uint256 offset = 4;

        // Decode the `account` address (20 bytes)
        assembly {
            account := mload(add(txData, add(offset, 32)))
        }
        offset += 32;

        // Decode the `token` address (20 bytes)
        assembly {
            token := mload(add(txData, add(offset, 32)))
        }
        offset += 32;

        // Decode the `claimable` uint256 (32 bytes)
        assembly {
            claimable := mload(add(txData, add(offset, 32)))
        }
    }

    ///@notice Decodes transaction data and proof from encoded transaction data
    ///@param txData Encoded transaction data
    ///@return account Account address
    ///@return reward Reward address
    ///@return claimable Claimable amount
    ///@return proof Array of proof elements
    function decodeTransactionDataAndProof(bytes memory txData)
        public
        pure
        returns (address account, address reward, uint256 claimable, bytes32[] memory proof)
    {
        // Skip the first 4 bytes (function selector)
        uint256 offset = 4;

        // Decode the `account` address (20 bytes)
        assembly {
            account := mload(add(txData, add(offset, 32)))
        }
        offset += 32;

        // Decode the `reward` address (20 bytes)
        assembly {
            reward := mload(add(txData, add(offset, 32)))
        }
        offset += 32;

        // Decode the `claimable` uint256 (32 bytes)
        assembly {
            claimable := mload(add(txData, add(offset, 32)))
        }
        offset += 32;

        // Decode the offset for the `proof` array
        uint256 proofOffset;
        assembly {
            proofOffset := mload(add(txData, add(offset, 32)))
        }
        offset = proofOffset + 4; // Move to the start of the proof data, after the function selector

        // Decode the length of the `proof` array
        uint256 proofLength;
        assembly {
            proofLength := mload(add(txData, add(offset, 32)))
        }
        offset += 32;

        // Allocate memory for the `proof` array
        proof = new bytes32[](proofLength);
        for (uint256 i = 0; i < proofLength; i++) {
            bytes32 proofElement;
            assembly {
                proofElement := mload(add(txData, add(offset, 32)))
            }
            proof[i] = proofElement;
            offset += 32;
        }
    }

    ///@notice Checks if the receiver is valid based on the decoded transaction data
    ///@param txData Encoded transaction data
    ///@param receiver Receiver address
    ///@return isValid True if the receiver is valid, false otherwise
    function receiverIsValid(bytes memory txData, address receiver) internal pure returns (bool) {
        (address account,,) = decodeTransactionData(txData);
        return account == receiver;
    }

    ///@notice Claims rewards for the receiver based on the decoded transaction data
    ///@param txDataEncoded Encoded transaction data
    ///@param revertIfReceiverInvalid True if the transaction should revert if the receiver is invalid
    function claimRewards(bytes memory txDataEncoded, bool revertIfReceiverInvalid) public {
        (address[] memory urd, bytes[] memory txData) = decodeMorphoV1Proofs(txDataEncoded);
        for (uint256 i = 0; i < urd.length;) {
            (address account, address token, uint256 claimable, bytes32[] memory proof) =
                decodeTransactionDataAndProof(txData[i]);
            if (revertIfReceiverInvalid) {
                if (account != msg.sender) {
                    revert Errors.InvalidMorphoRewardsReceiver();
                }
            }
            IClaimMorphoRewards(urd[i]).claim(account, token, claimable, proof);
            unchecked {
                i++;
            }
        }
    }

    ///@notice Claims rewards for the receiver based on the decoded transaction data
    ///@param owner Owner address
    ///@param txDataEncoded Encoded transaction data
    ///@param mode SendFundsModality (either 0 to send them to the owner or 1 not to send them to the owner)
    ///@param revertIfReceiverInvalid True if the transaction should revert if the receiver is invalid
    function claimRewardsAndSend(address owner, bytes memory txDataEncoded, uint8 mode, bool revertIfReceiverInvalid)
        public
    {
        (address[] memory urd, bytes[] memory txData) = decodeMorphoV1Proofs(txDataEncoded);
        address token;
        address account;
        uint256 claimable;
        uint256 claimed;
        bytes32[] memory proof;
        for (uint256 i = 0; i < urd.length;) {
            (account, token, claimable, proof) = decodeTransactionDataAndProof(txData[i]);
            if (revertIfReceiverInvalid) {
                if (account != msg.sender) {
                    revert Errors.InvalidMorphoRewardsReceiver();
                }
            }
            claimed = IClaimMorphoRewards(urd[i]).claim(account, token, claimable, proof);
            // SendFundsModality.SEND_THROUGH = SendFundsModality(uint8(0));
            if (mode == 0) {
                if (TokenHelper.attemptSafeTransfer(token, owner, claimed, false)) {
                    emit IClaimMorphoRewards.ClaimedRewards(token, claimed);
                }
            }
            unchecked {
                i++;
            }
        }
    }

    ///@notice Claims rewards for the receiver based on the decoded transaction data
    ///@param txDataEncoded Encoded transaction data
    ///@param revertIfReceiverInvalid True if the transaction should revert if the receiver is invalid. If this is called from the contract/strategy/proxy that is the depositor and hence the receiver, this should be set to true. Otherwis it should be set to false.
    ///@return rewardTokens Array of reward tokens
    function claimRewardsAndReturnRewardTokens(bytes memory txDataEncoded, bool revertIfReceiverInvalid)
        internal
        returns (address[] memory rewardTokens, uint256[] memory rewardAmounts)
    {
        (address[] memory urd, bytes[] memory txData) = decodeMorphoV1Proofs(txDataEncoded);
        address token;
        address account;
        uint256 claimable;
        uint256 claimed;
        bytes32[] memory proof;
        rewardTokens = new address[](urd.length);
        rewardAmounts = new uint256[](urd.length);
        for (uint256 i = 0; i < urd.length;) {
            (account, token, claimable, proof) = decodeTransactionDataAndProof(txData[i]);
            if (revertIfReceiverInvalid) {
                if (account != msg.sender) revert Errors.InvalidMorphoRewardsReceiver();
            }
            claimed = IClaimMorphoRewards(urd[i]).claim(account, token, claimable, proof);
            rewardTokens[i] = token;
            rewardAmounts[i] = claimed;
            unchecked {
                i++;
            }
        }
    }
}
