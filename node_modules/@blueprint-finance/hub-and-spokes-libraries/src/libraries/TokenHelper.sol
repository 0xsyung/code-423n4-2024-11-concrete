// SPDX-License-Identifier: AGPL-3.0
pragma solidity 0.8.24;

import {IERC20} from "@openzeppelin/contracts/token/ERC20/IERC20.sol";
import {SafeERC20} from "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol";
import {Errors} from "./Errors.sol";

library TokenHelper {
    using SafeERC20 for IERC20;

    ///@notice Attempts to transfer tokens to a recipient, optionally revets on failure
    ///@param token The token to transfer (may also be invalid token address)
    ///@param recipient The recipient of the transfer
    ///@param amount The amount to transfer
    ///@param revertOnBadAttempt Whether to revert on a failed transfer
    ///@return successfullTransfer Whether the transfer was successful
    function attemptSafeTransfer(address token, address recipient, uint256 amount, bool revertOnBadAttempt)
        internal
        returns (bool successfullTransfer)
    {
        successfullTransfer =
            _callOptionalReturnBool(IERC20(token), abi.encodeWithSelector(IERC20.transfer.selector, recipient, amount));
        if (!successfullTransfer && revertOnBadAttempt) {
            revert Errors.TransferFailed(token, recipient, amount);
        }
    }

    // OPENZEPPELIN SAFE ERC20 HELPER FUNCTIONS ///////////////////////////////

    /**
     * @dev This code is taken from the SafeERC20 library of OpenZeppelin Contracts v5.1.0
     * https://github.com/OpenZeppelin/openzeppelin-contracts/blob/v5.1.0/contracts/token/ERC20/utils/SafeERC20.sol
     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement
     * on the return value: the return value is optional (but if data is returned, it must not be false).
     * @param token The token targeted by the call.
     * @param data The call data (encoded using abi.encode or one of its variants).
     *
     * This is a variant of {_callOptionalReturn} that silently catches all reverts and returns a bool instead.
     */
    function _callOptionalReturnBool(IERC20 token, bytes memory data) private returns (bool) {
        bool success;
        uint256 returnSize;
        uint256 returnValue;
        assembly ("memory-safe") {
            success := call(gas(), token, 0, add(data, 0x20), mload(data), 0, 0x20)
            returnSize := returndatasize()
            returnValue := mload(0)
        }
        return success && (returnSize == 0 ? address(token).code.length > 0 : returnValue == 1);
    }
}
