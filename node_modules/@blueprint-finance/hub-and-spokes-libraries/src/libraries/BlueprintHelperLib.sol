// SPDX-License-Identifier: AGPL-3.0
pragma solidity 0.8.24;

import {SafeCast} from "@openzeppelin/contracts/utils/math/SafeCast.sol";
import {AddressLib} from "./AddressLib.sol";
import {Math} from "@openzeppelin/contracts/utils/math/Math.sol";
import {Errors} from "./Errors.sol";

interface IGetPriceAndSupported {
    function getPrice(address token) external view returns (uint256, bool);
}

library BlueprintHelperLib {
    using Math for uint256;

    /// @notice Encodes the reward amount and the last update timestamp into a single uint256 value.
    /// @param amount The reward amount to be encoded (up to 216 bits).
    /// @param timestamp The last update timestamp to be encoded (up to 40 bits).
    /// @return encoded The encoded value containing both the amount and the timestamp.
    function encodeRewardAndLastUpdate(uint256 amount, uint256 timestamp) public pure returns (uint256 encoded) {
        encoded = uint256(SafeCast.toUint40(timestamp)) | (uint256(SafeCast.toUint216(amount)) << 40);
    }

    /// @notice Decodes the encoded reward amount and last update timestamp, and checks if the timestamp is within the grace period.
    /// @param encoded The encoded value containing the amount and timestamp.
    /// @param gracePeriod The grace period for the reward's last update.
    /// @param currentTime The current block timestamp.
    /// @return amount The decoded reward amount.
    function decodeRewardAndLastUpdate(uint256 encoded, uint256 gracePeriod, uint256 currentTime)
        public
        pure
        returns (uint256 amount)
    {
        uint256 lastUpdate = uint256(uint40(encoded));
        if (lastUpdate + gracePeriod < currentTime) {
            return 0; // Returning 0 amount and default BASE_DENOMINATION of 1
        }
        return encoded >> 40;
    }

    function getAssetPriceFromExternalOracleInBase(address asset, uint256 externalOracleInfo, uint256 baseDenomination)
        public
        view
        returns (uint256 priceInBase)
    {
        (address oracle, uint8 decimals) = AddressLib.getAddressAndDecimals(externalOracleInfo);

        (uint256 priceInUSD, bool supported) = IGetPriceAndSupported(oracle).getPrice(asset);
        if (!supported) {
            revert Errors.PriceFeedNotSupportedErrorOnExternalOracle(asset);
        }

        priceInBase = priceInUSD.mulDiv(baseDenomination, 10 ** decimals);
    }
}
