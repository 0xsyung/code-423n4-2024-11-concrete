// SPDX-License-Identifier: AGPL-3.0
pragma solidity ^0.8.24;

import {WAD} from "../utils/Constants.sol";
import {Errors} from "./Errors.sol";
import {Math} from "@openzeppelin/contracts/utils/math/Math.sol";
import {
    MILLION,
    BP,
    WAD,
    TYPE_UINT2_MAX,
    TYPE_UINT4_MAX,
    TYPE_UINT8_MAX,
    TYPE_UINT20_MAX,
    FRACTION_BIT_LENGTH
} from "../utils/Constants.sol";
import {ProtectionData, ProtectionDataAbsolute} from "../utils/DataTypes.sol";

/// @title Protection Library V1
/// @notice This library provides functions to encode and decode protection data into uint256
/// @dev The encoding is done in a way that the data can be stored in a uint256 slot
/// @author Leonhard Horstmeyer
library ProtectionLibV1 {
    using Math for uint256;

    /// @notice Encodes the protection data into a uint256 value.
    /// @param protectionData The protection data to be encoded. It is of type ProtectionData (which can be found in the utils/DataTypes.sol).
    /// @return The encoded uint256 value.
    /// @dev The protection data is already in the right format of percentages with respect to the total promised amount. But the total promised amount is not inside this encoding. So the protection ONLY makes sense in conjunction with the total promised amount.
    /// @dev The function does some validity checks on the scalar values and subsequently on the arrays. Then it calls the internal function _encodeProtectionData.
    function encodeProtectionData(ProtectionData memory protectionData) internal pure returns (uint256) {
        _validateProtectionScalars(
            protectionData.numberOfTranches,
            protectionData.ltvProtectClaims,
            protectionData.ltvProtectForeclosure,
            protectionData.openingFeeRate,
            protectionData.cancellationFeeRate
        );

        if (protectionData.trancheAmountFractionInMillionth.length != protectionData.numberOfTranches) {
            revert Errors.InvalidTrancheNumber(uint8(protectionData.trancheAmountFractionInMillionth.length));
        }
        if (protectionData.trancheFeeRateInMillionth.length != protectionData.numberOfTranches) {
            revert Errors.InvalidTrancheNumber(uint8(protectionData.trancheFeeRateInMillionth.length));
        }
        for (uint8 i = 0; i < protectionData.numberOfTranches; i++) {
            if (protectionData.trancheAmountFractionInMillionth[i] > MILLION) {
                revert Errors.FractionExceedsUnityInMillionth();
            }
            if (protectionData.trancheFeeRateInMillionth[i] > MILLION) revert Errors.FractionExceedsUnityInMillionth();
        }
        return _encodeProtectionData(protectionData);
    }

    ///@notice Encodes the protection data into a uint256 value.
    ///@param protectionData The protection data to be encoded. It is of type ProtectionDataAbsolute (which can be found in the utils/DataTypes.sol).
    ///@dev This function is used to encode the protection data from relative or absolute values.
    function _encodeProtectionData(ProtectionData memory protectionData) internal pure returns (uint256 encoding) {
        encoding = uint256(protectionData.endTime) | (uint256(protectionData.numberOfTranches) << 40)
            | (uint256(protectionData.rightsEncoding) << 48) | (uint256(protectionData.ltvProtectClaims) << 56)
            | (uint256(protectionData.ltvProtectForeclosure) << (56 + 1 * FRACTION_BIT_LENGTH))
            | (uint256(protectionData.openingFeeRate) << (56 + 2 * FRACTION_BIT_LENGTH))
            | (uint256(protectionData.cancellationFeeRate) << (56 + 3 * FRACTION_BIT_LENGTH));
        for (uint8 i = 0; i < protectionData.numberOfTranches; i++) {
            encoding |=
                uint256(protectionData.trancheAmountFractionInMillionth[i]) << (56 + (4 + 2 * i) * FRACTION_BIT_LENGTH);
            encoding |= uint256(protectionData.trancheFeeRateInMillionth[i]) << (56 + (5 + 2 * i) * FRACTION_BIT_LENGTH);
        }
    }

    ///@notice Encodes the protection data from absolute values into a uint256 value.
    ///@param promisedAmountInToken The total promised amount in token.
    ///@param protectionData The protection data to be encoded. It is of type ProtectionDataAbsolute (which can be found in the utils/DataTypes.sol).
    ///@return The encoded uint256 value.
    ///@dev The function first conducts a few validity checks on the scalar values and subsequently on the arrays. It then turns the absolute values into fractions (from the ProtectionDataAbsolute struct) of the total promised amount and calls the internal function _encodeProtectionData.
    function encodeProtectionDataFromAbsoluteValues(
        uint256 promisedAmountInToken,
        ProtectionDataAbsolute memory protectionData
    ) internal pure returns (uint256) {
        if (protectionData.numberOfTranches > 3) revert Errors.NumberOfProtectionClaimsTooHigh();
        if (protectionData.ltvProtectForClaimsInBP > BP) revert Errors.FractionExceedsUnityInBP();
        if (protectionData.ltvProtectForForeclosureInBP > BP) revert Errors.FractionExceedsUnityInBP();
        if (protectionData.openingFeeInToken > promisedAmountInToken) {
            revert Errors.OpeningFeeExceedsPromisedAmount();
        }
        if (protectionData.cancellationFeeInToken > promisedAmountInToken) {
            revert Errors.CancellationFeeExceedsPromisedAmount();
        }
        if (protectionData.trancheAmountInToken.length != protectionData.numberOfTranches) {
            revert Errors.InvalidTrancheNumber(uint8(protectionData.trancheAmountInToken.length));
        }
        if (protectionData.trancheFeeInToken.length != protectionData.numberOfTranches) {
            revert Errors.InvalidTrancheNumber(uint8(protectionData.trancheFeeInToken.length));
        }
        uint256 cumulativeTrancheAmount = 0;
        for (uint8 i = 0; i < protectionData.numberOfTranches; i++) {
            if (protectionData.trancheAmountInToken[i] > promisedAmountInToken) {
                revert Errors.TrancheAmountExceedsPromisedAmount(i + 1);
            }
            cumulativeTrancheAmount += protectionData.trancheAmountInToken[i];
        }
        if (cumulativeTrancheAmount != promisedAmountInToken) {
            revert Errors.TrancheAmountsDoNotSumToPromisedAmount();
        }

        uint32[] memory trancheAmountAsFraction = new uint32[](protectionData.numberOfTranches);
        uint32[] memory trancheFeeAsFraction = new uint32[](protectionData.numberOfTranches);
        for (uint8 i = 0; i < protectionData.numberOfTranches; i++) {
            trancheAmountAsFraction[i] =
                uint32(protectionData.trancheAmountInToken[i].mulDiv(MILLION, promisedAmountInToken));
            trancheFeeAsFraction[i] = uint32(protectionData.trancheFeeInToken[i].mulDiv(MILLION, promisedAmountInToken));
        }

        ProtectionData memory returnProtectionData = ProtectionData({
            endTime: protectionData.endTime,
            numberOfTranches: protectionData.numberOfTranches,
            rightsEncoding: _encodeRights(
                protectionData.protocolRights,
                protectionData.remoteProxyRights,
                protectionData.remoteConcreteerRights,
                protectionData.remotePublicRights
            ),
            ltvProtectClaims: uint32(protectionData.ltvProtectForClaimsInBP.mulDiv(MILLION, BP)),
            ltvProtectForeclosure: uint32(protectionData.ltvProtectForForeclosureInBP.mulDiv(MILLION, BP)),
            openingFeeRate: uint32(protectionData.openingFeeInToken.mulDiv(MILLION, promisedAmountInToken)),
            cancellationFeeRate: uint32(protectionData.cancellationFeeInToken.mulDiv(MILLION, promisedAmountInToken)),
            trancheAmountFractionInMillionth: trancheAmountAsFraction,
            trancheFeeRateInMillionth: trancheFeeAsFraction
        });

        return _encodeProtectionData(returnProtectionData);
    }

    ///@notice Encodes the rights into a uint8 value (to be included into the protection data encoding).
    ///@param protocolRights The rights of the protocol.
    ///@param remoteProxyRights The rights of the remote proxy.
    ///@param remoteConcreteerRights The rights of the remote concreteer.
    ///@param remotePublicRights The rights of the remote public.
    ///@return The encoded uint8 value.
    ///@dev The rights can have one of 4 values, which are bit encoded. The first bit is for the right to close and foreclose, the second bit is for the right to claim and reclaim. The other rights are encoded in a similar way.
    ///@dev The protocol rights are by default (=0) enabled for both closing and foreclosing and claiming and reclaiming. Otherwise ([01]=0x01=1) means that claiming and reclaiming are disabled, ([10]=0x2=2) means that closure and foreclosure are disabled and ([11]=0x3=3) means that both are disabled.
    ///@dev The other rights are by default (=0) disabled for both closing and foreclosing and claiming and reclaiming. Otherwise ([01]=0x01=1) means that closure and foreclosure are enabled, ([10]=0x2=2) means that claiming and reclaiming are enabled and ([11]=0x3=3) means that both are enabled.
    function _encodeRights(
        uint8 protocolRights,
        uint8 remoteProxyRights,
        uint8 remoteConcreteerRights,
        uint8 remotePublicRights
    ) internal pure returns (uint8) {
        if (protocolRights > TYPE_UINT2_MAX) revert Errors.InvalidRightsEncoding(protocolRights);
        if (remoteProxyRights > TYPE_UINT2_MAX) revert Errors.InvalidRightsEncoding(remoteProxyRights);
        if (remoteConcreteerRights > TYPE_UINT2_MAX) revert Errors.InvalidRightsEncoding(remoteConcreteerRights);
        if (remotePublicRights > TYPE_UINT2_MAX) revert Errors.InvalidRightsEncoding(remotePublicRights);
        return protocolRights | (remoteProxyRights << 2) | (remoteConcreteerRights << 4) | (remotePublicRights << 6);
    }

    ///@notice A primitive to encode Protocol rights into a number between 0 and 3 depending on whether it can close and foreclose and whether it can claim and reclaim. (0=both enabled, 1=only claim and reclaim enabled, 2=only close and foreclose enabled, 3=both disabled).
    ///@param canCloseAndForeclose Whether the protocol can close and foreclose.
    ///@param canClaimAndReclaim Whether the protocol can claim and reclaim.
    ///@return The encoded uint8 value.
    ///@dev The protocol rights encoding works exactly inversely from the other rights.
    function _encodeProtocolRights(bool canCloseAndForeclose, bool canClaimAndReclaim) internal pure returns (uint8) {
        return (canCloseAndForeclose ? 0 : 1) | (canClaimAndReclaim ? 0 : 2);
    }

    ///@notice A primitive to encode non-protocol rights into a number between 0 and 3 depending on whether it can close and foreclose and whether it can claim and reclaim. (0=both disabled, 1=only close and foreclose enabled, 2=only claim and reclaim enabled, 3=both enabled).
    function _encodeNonProtocolRights(bool canCloseAndForeclose, bool canClaimAndReclaim)
        internal
        pure
        returns (uint8)
    {
        return (canCloseAndForeclose ? 1 : 0) | (canClaimAndReclaim ? 2 : 0);
    }

    ///@notice Encodes the rights into a uint8 value (to be included into the protection data encoding).
    ///@param protocolCanCloseAndForeclose Whether the protocol can close and foreclose.
    ///@param protocolCanClaimAndReclaim Whether the protocol can claim and reclaim.
    ///@param remoteProxyCanCloseAndForeclose Whether the remote proxy can close and foreclose.
    ///@param remoteProxyCanClaimAndReclaim Whether the remote proxy can claim and reclaim.
    ///@param remoteConcreteerCanCloseAndForeclose Whether the remote concreteer can close and foreclose.
    ///@param remoteConcreteerCanClaimAndReclaim Whether the remote concreteer can claim and reclaim.
    ///@param remotePublicCanCloseAndForeclose Whether the remote public can close and foreclose.
    ///@param remotePublicCanClaimAndReclaim Whether the remote public can claim and reclaim.
    ///@return The encoded uint8 value.
    ///@dev The rights can have one of 4 values, which are bit encoded.
    function encodeRightsFromFineControlFlags(
        bool protocolCanCloseAndForeclose,
        bool protocolCanClaimAndReclaim,
        bool remoteProxyCanCloseAndForeclose,
        bool remoteProxyCanClaimAndReclaim,
        bool remoteConcreteerCanCloseAndForeclose,
        bool remoteConcreteerCanClaimAndReclaim,
        bool remotePublicCanCloseAndForeclose,
        bool remotePublicCanClaimAndReclaim
    ) internal pure returns (uint8) {
        return _encodeProtocolRights(protocolCanCloseAndForeclose, protocolCanClaimAndReclaim)
            | (_encodeNonProtocolRights(remoteProxyCanCloseAndForeclose, remoteProxyCanClaimAndReclaim) << 2)
            | (_encodeNonProtocolRights(remoteConcreteerCanCloseAndForeclose, remoteConcreteerCanClaimAndReclaim) << 4)
            | (_encodeNonProtocolRights(remotePublicCanCloseAndForeclose, remotePublicCanClaimAndReclaim) << 6);
    }

    ///@notice Encodes rights from flags. It sets the maximal rights possible (claim, reclaim, close, foreclose) if the flag is true.
    ///@param protocolCanIntervene Whether the protocol can intervene.
    ///@param remoteProxyCanIntervene Whether the remote proxy can intervene.
    ///@param remoteConcreteerCanIntervene Whether the remote concreteer can intervene.
    ///@param remotePublicCanIntervene Whether the remote public can intervene.
    ///@return The encoded uint8 value.
    ///@dev The default is that the rights are enabled for the protocol and for the others not. Since in the evm by default every uint256 value (such as the protocol Info encoding) is zero, it would be great to reflect the default rights encoding also in this case where no protection exists (i.e. the protocol Info = 0).
    ///@dev We solved this issue by reversing the rights encoding for the protocol.vs the other parties. For the protocol the default is that it can close and foreclose and claim and reclaim. For the others the default is that they can't do anything.
    function encodeRightsFromFlags(
        bool protocolCanIntervene,
        bool remoteProxyCanIntervene,
        bool remoteConcreteerCanIntervene,
        bool remotePublicCanIntervene
    ) internal pure returns (uint8) {
        return (protocolCanIntervene ? 0 : 3) | (remoteProxyCanIntervene ? (3 << 2) : 0)
            | (remoteConcreteerCanIntervene ? (3 << 4) : 0) | (remotePublicCanIntervene ? (3 << 6) : 0);
    }

    ///@notice Decodes the entire rights encoding from the protection data uint256 value.
    ///@param encoding The encoded uint256 value.
    ///@return The rights encoding as a uint8 value.
    ///@dev The reponse still needs to be decoded furhter to obtain the rights of the various parties.
    function getRightsEncoding(uint256 encoding) internal pure returns (uint8) {
        return uint8(TYPE_UINT8_MAX & encoding >> 48);
    }

    ///@notice Decodes the protocol rights from the rights encoding.
    ///@param rights The encoded uint8 value.
    ///@return The protocol rights as a uint8 value.
    ///@dev The response is a number between 0 and 3 depending on whether it can close and foreclose and whether it can claim and reclaim. (0=both enabled, 1=only claim and reclaim enabled, 2=only close and foreclose enabled, 3=both disabled).
    function _getProtocolRightsFromEncodedRights(uint8 rights) internal pure returns (uint8) {
        return uint8(uint256(rights) & TYPE_UINT2_MAX);
    }

    /// @notice Decodes the remote proxy rights from the rights encoding.
    /// @param rights The encoded uint8 value.
    /// @return The remote proxy rights as a uint8 value.
    /// @dev The response is a number between 0 and 3 depending on whether it can close and foreclose and whether it can claim and reclaim.
    /// @dev (0=both disabled, 1=only close and foreclose enabled, 2=only claim and reclaim enabled, 3=both enabled).
    function _getRemoteProxyRightsFromEncodedRights(uint8 rights) internal pure returns (uint8) {
        return uint8((uint256(rights) >> 2) & TYPE_UINT2_MAX);
    }

    /// @notice Decodes the remote concreteer rights from the rights encoding.
    /// @param rights The encoded uint8 value.
    /// @return The remote concreteer rights as a uint8 value.
    /// @dev The response is a number between 0 and 3 depending on whether it can close and foreclose and whether it can claim and reclaim.
    /// @dev (0=both disabled, 1=only close and foreclose enabled, 2=only claim and reclaim enabled, 3=both enabled).
    /// @dev A concreteer here is a placeholder name for special accounts that can be whitelisted on the remote registry.
    function _getRemoteConcreteerRightsFromEncodedRights(uint8 rights) internal pure returns (uint8) {
        return uint8((uint256(rights) >> 4) & TYPE_UINT2_MAX);
    }

    /// @notice Decodes the remote public rights from the rights encoding.
    /// @param rights The encoded uint8 value.
    /// @return The remote public rights as a uint8 value.
    /// @dev The response is a number between 0 and 3 depending on whether it can close and foreclose and whether it can claim and reclaim.
    /// @dev (0=both disabled, 1=only close and foreclose enabled, 2=only claim and reclaim enabled, 3=both enabled).
    function _getRemotePublicRightsFromEncodedRights(uint8 rights) internal pure returns (uint8) {
        return uint8((uint256(rights) >> 6) & TYPE_UINT2_MAX);
    }

    /// @notice An internal helper function to retrieve the claims and reclaims rights for a given 2-bit rights encoding that is not for the protocol.
    /// @param twoBitRightsEncoding The 2-bit rights encoding.
    /// @return Whether the party can claim and reclaim.
    function _getNonProtocolEnabledForClaimsAndReclaims(uint8 twoBitRightsEncoding) internal pure returns (bool) {
        return (twoBitRightsEncoding & 2) == 2;
    }

    /// @notice An internal helper function to retrieve the closure and foreclosure rights for a given 2-bit rights encoding that is not for the protocol.
    /// @param twoBitRightsEncoding The 2-bit rights encoding.
    /// @return Whether the party can close and foreclose.
    function _getNonProtocolEnabledForClosureAndForeclosure(uint8 twoBitRightsEncoding) internal pure returns (bool) {
        return (twoBitRightsEncoding & 1) == 1;
    }

    /// @notice An internal helper function that retrieves the protocol rights for claims and reclaims for a given 2-bit rights encoding.
    /// @param twoBitRightsEncoding The encoded rights.
    /// @return Whether the protocol can claim and reclaim.
    function _getProtocolEnabledForClaimsAndReclaims(uint8 twoBitRightsEncoding) internal pure returns (bool) {
        return (twoBitRightsEncoding & 2) == 0;
    }

    /// @notice An internal helper function that retrieves the protocol rights for closure and foreclosure for a given 2-bit rights encoding.
    /// @param twoBitRightsEncoding The encoded rights.
    /// @return Whether the protocol can close and foreclose.
    function _getProtocolEnabledForClosureAndForeclosure(uint8 twoBitRightsEncoding) internal pure returns (bool) {
        return (twoBitRightsEncoding & 1) == 0;
    }

    /// @notice Retrieves the information whether the protocol can close and foreclose.
    /// @param encoding The encoded uint256 value.
    /// @return Whether the protocol can close and foreclose.
    /// @dev uses the internal helper function _getProtocolEnabledForClosureAndForeclosure.
    function getProtocolEnabledForClaimsAndReclaims(uint256 encoding) internal pure returns (bool) {
        return _getProtocolEnabledForClaimsAndReclaims(getProtocolRights(encoding));
    }

    /// @notice Retrieves the information whether the protocol can claim and reclaim.
    /// @param encoding The encoded uint256 value.
    /// @return Whether the protocol can claim and reclaim.
    /// @dev uses the internal helper function _getProtocolEnabledForClaimsAndReclaims.
    function getProtocolEnabledForClosureAndForeclosure(uint256 encoding) internal pure returns (bool) {
        return _getProtocolEnabledForClosureAndForeclosure(getProtocolRights(encoding));
    }

    /// @notice Retrieves the rights encoding of the Remote Protocol Proxy Contract.
    /// @param encoding The encoded uint256 value.
    /// @return The rights encoding as a uint8 value.
    function getRemoteProxyRights(uint256 encoding) internal pure returns (uint8) {
        return uint8(TYPE_UINT2_MAX & (encoding >> 50));
    }

    /// @notice Checks whether the Remote Protocol Proxy Contract is allowed to Claim or Reclaim.
    /// @param encoding The encoded uint256 value.
    /// @return The rights encoding as a uint8 value.
    function getRemoteProxyEnabledForClaimsAndReclaims(uint256 encoding) internal pure returns (bool) {
        return _getNonProtocolEnabledForClaimsAndReclaims(getRemoteProxyRights(encoding));
    }

    /// @notice Checks whether the Remote Protocol Proxy Contract is allowed to Close or foreclose a position.
    /// @param encoding The encoded uint256 value.
    /// @return The rights encoding as a uint8 value.
    function getRemoteProxyEnabledForClosureAndForeclosure(uint256 encoding) internal pure returns (bool) {
        return _getNonProtocolEnabledForClosureAndForeclosure(getRemoteProxyRights(encoding));
    }

    /// @notice Retrieves the rights encoding of whitelisted Concreteer accounts.
    /// @param encoding The encoded uint256 value.
    /// @return The rights encoding as a uint8 value.
    function getRemoteConcreteerRights(uint256 encoding) internal pure returns (uint8) {
        return uint8(TYPE_UINT2_MAX & (encoding >> 52));
    }

    /// @notice Checks whether whitelisted Concreteer accounts are allowed to Claim or Reclaim.
    /// @param encoding The encoded uint256 value.
    /// @return The rights encoding as a uint8 value.
    function getRemoteConcreteerEnabledForClaimsAndReclaims(uint256 encoding) internal pure returns (bool) {
        return _getNonProtocolEnabledForClaimsAndReclaims(getRemoteConcreteerRights(encoding));
    }

    /// @notice Checks whetehr whitelisted Concreteer accounts are allowed to Close or foreclose a position.
    function getRemoteConcreteerEnabledForClosureAndForeclosure(uint256 encoding) internal pure returns (bool) {
        return _getNonProtocolEnabledForClosureAndForeclosure(getRemoteConcreteerRights(encoding));
    }

    /// @notice Retrieves the rights encoding of the Remote Public Contract.
    /// @param encoding The encoded uint256 value.
    /// @return The rights encoding as a uint8 value.
    function getRemotePublicRights(uint256 encoding) internal pure returns (uint8) {
        return uint8(TYPE_UINT2_MAX & (encoding >> 54));
    }

    /// @notice Checks whether the Remote Public Contract is allowed to Claim or Reclaim.
    /// @param encoding The encoded uint256 value.
    /// @return The rights encoding as a uint8 value.
    function getRemotePublicEnabledForClaimsAndReclaims(uint256 encoding) internal pure returns (bool) {
        return _getNonProtocolEnabledForClaimsAndReclaims(getRemotePublicRights(encoding));
    }

    /// @notice Checks whether the Remote Public Contract is allowed to Close or foreclose a position.
    /// @param encoding The encoded uint256 value.
    /// @return The rights encoding as a uint8 value.
    function getRemotePublicEnabledForClosureAndForeclosure(uint256 encoding) internal pure returns (bool) {
        return _getNonProtocolEnabledForClosureAndForeclosure(getRemotePublicRights(encoding));
    }

    /// @notice Gets the encoded Protocol Rights (0-3) from the protection encoding.
    /// @param encoding The encoded uint256 value.
    /// @return The encoded Protocol Rights.
    /// @dev The rights are encoded in a uint8 value. A value of 0 means that both closing and foreclosing and claiming and reclaiming are enabled. Then 1 means that only claiming and reclaiming are enabled, 2 means that only closing and foreclosing are enabled and 3 means that both are disabled.
    function getProtocolRights(uint256 encoding) internal pure returns (uint8) {
        return uint8(TYPE_UINT2_MAX & (encoding >> 48));
    }

    /// @notice Updates the protection encoding with a new rights encoding.
    /// @param encoding The encoded uint256 value.
    /// @param encodedRights The new rights encoding.
    /// @return The updated encoded uint256 value.
    function updateRightsEncoding(uint256 encoding, uint8 encodedRights) internal pure returns (uint256) {
        uint256 mask = uint256(TYPE_UINT8_MAX << 48);
        uint256 newValue = uint256(encodedRights) << 48;
        return (encoding & ~mask) | (newValue & mask);
    }

    /// @notice Updates the protection encoding with a new rights encoding from individual party's encoded rights (numbers between 0 and 3).
    /// @param encoding The encoded uint256 value.
    /// @param protocolRights The protocol rights.
    /// @param remoteProxyRights The remote proxy rights.
    /// @param remoteConcreteerRights The remote concreteer rights.
    /// @param remotePublicRights The remote public rights.
    function updateRightsEncodingWithUint8(
        uint256 encoding,
        uint8 protocolRights,
        uint8 remoteProxyRights,
        uint8 remoteConcreteerRights,
        uint8 remotePublicRights
    ) internal pure returns (uint256) {
        uint256 mask = uint256(TYPE_UINT8_MAX << 48);
        return (encoding & ~mask)
            | (
                (
                    (uint256(protocolRights) << 48) | (uint256(remoteProxyRights) << 50)
                        | (uint256(remoteConcreteerRights) << 52) | (uint256(remotePublicRights) << 54)
                ) & mask
            );
    }

    /// @notice Updates the protection encoding with a new rights encoding from boolean flags.
    /// @param encoding The encoded uint256 value.
    /// @param protocolCanCloseAndForeclose Whether the protocol can close and foreclose.
    /// @param protocolCanClaimAndReclaim Whether the protocol can claim and reclaim.
    /// @param remoteProxyCanCloseAndForeclose Whether the remote proxy can close and foreclose.
    /// @param remoteProxyCanClaimAndReclaim Whether the remote proxy can claim and reclaim.
    /// @param remoteConcreteerCanCloseAndForeclose Whether the remote concreteer can close and foreclose.
    /// @param remoteConcreteerCanClaimAndReclaim Whether the remote concreteer can claim and reclaim.
    /// @param remotePublicCanCloseAndForeclose Whether the remote public can close and foreclose.
    /// @param remotePublicCanClaimAndReclaim Whether the remote public can claim and reclaim.
    /// @return The updated encoded uint256 value.
    function updateRightsEncodingWithBooleanFlags(
        uint256 encoding,
        bool protocolCanCloseAndForeclose,
        bool protocolCanClaimAndReclaim,
        bool remoteProxyCanCloseAndForeclose,
        bool remoteProxyCanClaimAndReclaim,
        bool remoteConcreteerCanCloseAndForeclose,
        bool remoteConcreteerCanClaimAndReclaim,
        bool remotePublicCanCloseAndForeclose,
        bool remotePublicCanClaimAndReclaim
    ) internal pure returns (uint256) {
        return updateRightsEncodingWithUint8(
            encoding,
            _encodeProtocolRights(protocolCanCloseAndForeclose, protocolCanClaimAndReclaim),
            _encodeNonProtocolRights(remoteProxyCanCloseAndForeclose, remoteProxyCanClaimAndReclaim),
            _encodeNonProtocolRights(remoteConcreteerCanCloseAndForeclose, remoteConcreteerCanClaimAndReclaim),
            _encodeNonProtocolRights(remotePublicCanCloseAndForeclose, remotePublicCanClaimAndReclaim)
        );
    }

    /// @notice Updates the Concrete Lite Foreclosure Fee Fraction In Wad
    /// @param encoding The encoded uint256 value.
    /// @param liteForeclosureFeeFractionInWad The new lite foreclosure fee fraction in Wad.
    /// @return The updated encoded uint256 value.
    function updateLiteForeclosureFeeFractionInWad(uint256 encoding, uint256 liteForeclosureFeeFractionInWad)
        internal
        pure
        returns (uint256)
    {
        if (liteForeclosureFeeFractionInWad > WAD) revert Errors.ExceedsWadPrecision();
        uint256 mask = uint256(TYPE_UINT20_MAX << 56);
        uint256 newValue = liteForeclosureFeeFractionInWad.mulDiv(MILLION, WAD) << 56;
        return (encoding & ~mask) | (newValue & mask);
    }

    /// @notice Updates the LTV Protection Buffer For Claims In Wad
    /// @param encoding The encoded uint256 value.
    /// @param ltvProtectBufferForClaimsInWad The new LTV protect buffer for claims in Wad.
    /// @return The updated encoded uint256 value.
    /// @dev the buffer is a value between 0 and 1. The protection threshold can be calculated from the liquidation threshold liq_ltv in a multiplicative way: protection_threshold = liq_ltv * (1 - buffer).
    function updateLtvProtectForClaims(uint256 encoding, uint256 ltvProtectBufferForClaimsInWad)
        internal
        pure
        returns (uint256)
    {
        if (ltvProtectBufferForClaimsInWad > WAD) revert Errors.ExceedsWadPrecision();
        uint256 mask = uint256(TYPE_UINT20_MAX << 56);
        uint256 newValue = ltvProtectBufferForClaimsInWad.mulDiv(MILLION, WAD) << 56;
        return (encoding & ~mask) | (newValue & mask);
    }

    /// @notice Updates the LTV Protection Buffer For Foreclosure In Wad
    /// @param encoding The encoded uint256 value.
    /// @param ltvProtectBufferForForeclosureInWad The new LTV protect buffer for foreclosure in Wad.
    /// @return The updated encoded uint256 value.
    /// @dev the buffer is a value between 0 and 1. The protection threshold can be calculated from the liquidation threshold liq_ltv in a multiplicative way: protection_threshold = liq_ltv * (1 - buffer).
    function updateLtvProtectForForeclosure(uint256 encoding, uint256 ltvProtectBufferForForeclosureInWad)
        internal
        pure
        returns (uint256)
    {
        if (ltvProtectBufferForForeclosureInWad > WAD) revert Errors.ExceedsWadPrecision();
        uint256 mask = uint256(TYPE_UINT20_MAX << (56 + 1 * FRACTION_BIT_LENGTH));
        uint256 newValue = ltvProtectBufferForForeclosureInWad.mulDiv(MILLION, WAD) << (56 + 1 * FRACTION_BIT_LENGTH);
        return (encoding & ~mask) | (newValue & mask);
    }

    /// @notice Updates the the number of claims in the protection encoding.
    /// @param encoding The encoded uint256 value.
    /// @param numberOfClaims The new number of claims.
    /// @return The updated encoded uint256 value.
    function updateNumberOfClaims(uint256 encoding, uint8 numberOfClaims) internal pure returns (uint256) {
        if (numberOfClaims > TYPE_UINT4_MAX) revert Errors.NumberOfProtectionClaimsTooHigh();
        uint256 mask = uint256(TYPE_UINT4_MAX << 44);
        uint256 newValue = uint256(numberOfClaims) << 44;
        return (encoding & ~mask) | (newValue & mask);
    }

    ///@notice Updates the concrete lite enabled flag in the protection encoding.
    ///@param encoding The encoded uint256 value.
    ///@param enabled The new value of the concrete lite enabled flag.
    ///@return The updated encoded uint256 value.
    ///@dev The same slot as for number of claims is used for the concrete lite enabled flag.
    ///@dev Both the protection encoding and the concrete lite encoding use this library for encoding, decoding and updating.
    function updateConcreteLiteEnabled(uint256 encoding, bool enabled) internal pure returns (uint256) {
        uint256 mask = uint256(TYPE_UINT4_MAX << 44);
        uint256 newValue = uint256(enabled ? 1 : 0) << 44;
        return (encoding & ~mask) | (newValue & mask);
    }

    ///@notice Updates the number of tranches in the protection encoding by one.
    ///@param encoding The encoded uint256 value.
    ///@return The updated encoded uint256 value.
    function incrementNumberOfClaims(uint256 encoding) internal pure returns (uint256) {
        uint8 numberOfClaims = getNumberOfClaims(encoding);
        if (numberOfClaims == TYPE_UINT4_MAX) revert Errors.NumberOfProtectionClaimsTooHigh();
        return updateNumberOfClaims(encoding, numberOfClaims + 1);
    }

    /// @notice Get the time at which the protection matures.
    /// @param encoding The encoded uint256 value.
    /// @return The time at which the protection matures.
    function getEndTime(uint256 encoding) internal pure returns (uint40) {
        return uint40(encoding);
    }

    /// @notice Get the LTV Protection Buffer For Claims In Wad.
    /// @param encoding The encoded uint256 value.
    /// @return The LTV protect buffer for claims in Wad.
    /// @dev the buffer is a value between 0 and 1. The protection threshold can be calculated from the liquidation threshold liq_ltv in a multiplicative way: protection_threshold = liq_ltv * (1 - buffer).
    function getLtvProtectBufferForClaimsInWad(uint256 encoding) internal pure returns (uint256) {
        return uint256(TYPE_UINT20_MAX & (encoding >> 56)).mulDiv(WAD, MILLION);
    }

    /// @notice Get the Lite Foreclosure Fee Fraction In Wad. (Not used in V1 of the hub protocol)
    /// @param encoding The encoded uint256 value.
    /// @return The lite foreclosure fee fraction in Wad.
    /// @dev This encoding is currently not used inside the lite encoding!
    function getLiteForeclosureFeeFractionInWad(uint256 encoding) internal pure returns (uint256) {
        return uint256(TYPE_UINT20_MAX & (encoding >> 56)).mulDiv(WAD, MILLION);
    }

    /// @notice Get the LTV Protection Buffer For Claims in Millionth.
    /// @param encoding The encoded uint256 value.
    /// @return The LTV protect buffer for claims in Millionth.
    function getLtvProtectForClaimsInMillionth(uint256 encoding) internal pure returns (uint256) {
        return uint256(TYPE_UINT20_MAX & (encoding >> 56));
    }

    /// @notice Get the LTV Protection Buffer For Foreclosure in Wad.
    /// @param encoding The encoded uint256 value.
    /// @return The LTV protect buffer for foreclosure in Wad.
    function getLtvProtectBufferForForeclosureInWad(uint256 encoding) internal pure returns (uint256) {
        return uint256(TYPE_UINT20_MAX & (encoding >> (56 + 1 * FRACTION_BIT_LENGTH))).mulDiv(WAD, MILLION);
    }

    /// @notice Get the LTV Protection Buffer For Foreclosure in Millionth.
    /// @param encoding The encoded uint256 value.
    /// @return The LTV protect buffer for foreclosure in Millionth.
    function getLtvProtectForForeclosureInMillionth(uint256 encoding) internal pure returns (uint256) {
        return uint256(TYPE_UINT20_MAX & (encoding >> (56 + 1 * FRACTION_BIT_LENGTH)));
    }

    /// @notice Get the number of available tranches in the protection encoding.
    /// @param encoding The encoded uint256 value.
    /// @return The number of claims.
    function getNumberOfTranches(uint256 encoding) internal pure returns (uint8) {
        return uint8(TYPE_UINT4_MAX & (encoding >> 40));
    }

    /// @notice Get the number of issued claims in the protection encoding.
    /// @param encoding The encoded uint256 value.
    /// @return The number of claims.
    function getNumberOfClaims(uint256 encoding) internal pure returns (uint8) {
        return uint8(TYPE_UINT4_MAX & (encoding >> 44));
    }

    /// @notice Checks whether the concrete lite feature is enabled.
    /// @param encoding The encoded uint256 value.
    /// @return Whether the concrete lite feature is enabled.
    function getConcreteLiteEnabled(uint256 encoding) internal pure returns (bool) {
        uint8 enabled = uint8(TYPE_UINT4_MAX & (encoding >> 44));
        return enabled == 1;
    }

    /// @notice Get the tranche amount fraction in Wad for a given tranche.
    /// @param encoding The encoded uint256 value.
    /// @param tranche The tranche number.
    /// @return The fraction of the promised amount that is disbursed in the given tranche.
    /// @dev The tranche number should be between 1 and the number of available tranches.
    function getTrancheAmountFractionInWad(uint256 encoding, uint8 tranche) internal pure returns (uint256) {
        uint256 numberOfTranches = getNumberOfTranches(encoding);
        if ((tranche < 1) || (tranche > numberOfTranches)) revert Errors.InvalidTrancheNumber(tranche);
        uint256 offset = (56 + 4 * FRACTION_BIT_LENGTH) + 40 * (tranche - 1);
        return uint256(TYPE_UINT20_MAX & (encoding >> offset)).mulDiv(WAD, MILLION);
    }

    /// @notice Get the tranche fee fraction in Wad for a given tranche.
    /// @param encoding The encoded uint256 value.
    /// @param tranche The tranche number.
    /// @return The fraction of the promised amount that is charged as a fee in the given tranche.
    /// @dev The tranche number should be between 1 and the number of available tranches.
    function getTrancheFeeFractionInWad(uint256 encoding, uint8 tranche) internal pure returns (uint256) {
        uint256 numberOfTranches = getNumberOfTranches(encoding);
        if ((tranche < 1) || (tranche > numberOfTranches)) revert Errors.InvalidTrancheNumber(tranche);
        uint256 offset = (56 + 5 * FRACTION_BIT_LENGTH) + 40 * (tranche - 1);
        return uint256(TYPE_UINT20_MAX & (encoding >> offset)).mulDiv(WAD, MILLION);
    }

    /// @notice Get the opening fee fraction in Wad.
    /// @param encoding The encoded uint256 value.
    /// @return The opening fee fraction in Wad.
    function getOpeningFeeFractionInWad(uint256 encoding) internal pure returns (uint256) {
        return uint256(TYPE_UINT20_MAX & (encoding >> (56 + 2 * FRACTION_BIT_LENGTH))).mulDiv(WAD, MILLION);
    }

    /// @notice Get the cancellation fee fraction in Wad.
    /// @param encoding The encoded uint256 value.
    /// @return The cancellation fee fraction in Wad.
    function getCancellationFeeFractionInWad(uint256 encoding) internal pure returns (uint256) {
        return uint256(TYPE_UINT20_MAX & (encoding >> (56 + 3 * FRACTION_BIT_LENGTH))).mulDiv(WAD, MILLION);
    }

    /// @notice Get the tranche amount from the encoding, given the total promised amount and the tranche number.
    /// @param encoding The encoded uint256 value.
    /// @param tranche The tranche number.
    /// @param totalPromisedAmount The total promised amount.
    /// @return The actual amount that is disbursed in the given tranche.
    /// @dev The denomination of the amount depends on the denomination of the total promised amount. In most cases this will be in collateral denomination.
    /// @dev The tranche number should be between 1 and the number of available tranches.
    function getTrancheAmount(uint256 encoding, uint8 tranche, uint256 totalPromisedAmount)
        internal
        pure
        returns (uint256)
    {
        return getTrancheAmountFractionInWad(encoding, tranche).mulDiv(totalPromisedAmount, WAD);
    }

    /// @notice Get the tranche fee from the encoding, given the total promised amount and the tranche number.
    /// @param encoding The encoded uint256 value.
    /// @param tranche The tranche number.
    /// @param totalPromisedAmount The total promised amount.
    /// @return The actual fee that is charged in the given tranche.
    /// @dev The denomination of the fee depends on the denomination of the total promised amount.
    /// @dev The tranche number should be between 1 and the number of available tranches.
    function getTrancheFee(uint256 encoding, uint8 tranche, uint256 totalPromisedAmount)
        internal
        pure
        returns (uint256)
    {
        return getTrancheFeeFractionInWad(encoding, tranche).mulDiv(totalPromisedAmount, WAD);
    }

    /// @notice Get the opening fee from the encoding, given the total promised amount.
    /// @param encoding The encoded uint256 value.
    /// @param totalPromisedAmount The total promised amount.
    /// @return The actual opening fee rather than the fraction.
    /// @dev The denomination of the fee depends on the denomination of the total promised amount.
    function getOpeningFee(uint256 encoding, uint256 totalPromisedAmount) internal pure returns (uint256) {
        return getOpeningFeeFractionInWad(encoding).mulDiv(totalPromisedAmount, WAD);
    }

    /// @notice Get the cancellation fee from the encoding, given the total promised amount.
    /// @param encoding The encoded uint256 value.
    /// @param totalPromisedAmount The total promised amount.
    /// @return The actual cancellation fee rather than the fraction.
    /// @dev The denomination of the fee depends on the denomination of the total promised amount.
    function getCancellationFee(uint256 encoding, uint256 totalPromisedAmount) internal pure returns (uint256) {
        return getCancellationFeeFractionInWad(encoding).mulDiv(totalPromisedAmount, WAD);
    }

    /// @notice Decodes the protection data from the encoded uint256 value.
    /// @param encoding The encoded uint256 value.
    /// @return endTime The time at which the protection matures.
    /// @return numberOfTranches The number of available tranches.
    /// @return rightsEncoding The rights encoding (see getRightsEncoding).
    /// @return ltvProtectClaims The LTV protection BUFFER for claims in Millionth.
    /// @return ltvProtectForeclosure The LTV protection BUFFER for foreclosure in Millionth.
    /// @return openingFeeRate The opening fee in Millionth.
    /// @return cancellationFeeRate The cancellation fee in Millionth.
    /// @return trancheOneAmountFractionInMillionth The fraction of the promised amount that is disbursed in the first tranche in Millionth.
    /// @return trancheOneFeeRateInMillionth The fraction of the promised amount that is charged as a fee in the first tranche in Millionth.
    /// @return trancheTwoAmountFractionInMillionth The fraction of the promised amount that is disbursed in the second tranche in Millionth.
    /// @return trancheTwoFeeRateInMillionth The fraction of the promised amount that is charged as a fee in the second tranche in Millionth.
    /// @return trancheThreeAmountFractionInMillionth The fraction of the promised amount that is disbursed in the third tranche in Millionth.
    /// @return trancheThreeFeeRateInMillionth The fraction of the promised amount that is charged as a fee in the third tranche in Millionth.
    function decodeProtectionData(uint256 encoding)
        internal
        pure
        returns (
            uint40 endTime,
            uint8 numberOfTranches,
            uint8 rightsEncoding,
            uint32 ltvProtectClaims,
            uint32 ltvProtectForeclosure,
            uint32 openingFeeRate,
            uint32 cancellationFeeRate,
            uint32 trancheOneAmountFractionInMillionth,
            uint32 trancheOneFeeRateInMillionth,
            uint32 trancheTwoAmountFractionInMillionth,
            uint32 trancheTwoFeeRateInMillionth,
            uint32 trancheThreeAmountFractionInMillionth,
            uint32 trancheThreeFeeRateInMillionth
        )
    {
        endTime = uint40(encoding);
        numberOfTranches = uint8(TYPE_UINT4_MAX & (encoding >> 40));
        rightsEncoding = uint8(TYPE_UINT8_MAX & (encoding >> 48));
        ltvProtectClaims = uint32(TYPE_UINT20_MAX & (encoding >> 56));
        ltvProtectForeclosure = uint32(TYPE_UINT20_MAX & (encoding >> (56 + 1 * FRACTION_BIT_LENGTH)));
        openingFeeRate = uint32(TYPE_UINT20_MAX & (encoding >> (56 + 2 * FRACTION_BIT_LENGTH)));
        cancellationFeeRate = uint32(TYPE_UINT20_MAX & (encoding >> (56 + 3 * FRACTION_BIT_LENGTH)));
        trancheOneAmountFractionInMillionth = uint32(TYPE_UINT20_MAX & (encoding >> (56 + 4 * FRACTION_BIT_LENGTH)));
        trancheOneFeeRateInMillionth = uint32(TYPE_UINT20_MAX & (encoding >> (56 + 5 * FRACTION_BIT_LENGTH)));
        trancheTwoAmountFractionInMillionth = uint32(TYPE_UINT20_MAX & (encoding >> (56 + 6 * FRACTION_BIT_LENGTH)));
        trancheTwoFeeRateInMillionth = uint32(TYPE_UINT20_MAX & (encoding >> (56 + 7 * FRACTION_BIT_LENGTH)));
        trancheThreeAmountFractionInMillionth = uint32(TYPE_UINT20_MAX & (encoding >> (56 + 8 * FRACTION_BIT_LENGTH)));
        trancheThreeFeeRateInMillionth = uint32(TYPE_UINT20_MAX & (encoding >> (56 + 9 * FRACTION_BIT_LENGTH)));
    }

    ///@notice Validate the protection data
    ///@param encoding The encoded protection data
    ///@dev This function is used to validate the protection data before it is used in the protocol. It reverts if the data is invalid.
    function validateEncodedProtection(uint256 encoding) internal view {
        (
            uint40 endTime,
            uint8 numberOfTranches,
            ,
            uint32 ltvProtectClaims,
            uint32 ltvProtectForeclosure,
            uint32 openingFeeRate,
            uint32 cancellationFeeRate,
            uint32 trancheOneAmountFractionInMillionth,
            uint32 trancheOneFeeRateInMillionth,
            uint32 trancheTwoAmountFractionInMillionth,
            uint32 trancheTwoFeeRateInMillionth,
            uint32 trancheThreeAmountFractionInMillionth,
            uint32 trancheThreeFeeRateInMillionth
        ) = decodeProtectionData(encoding);

        if (endTime < block.timestamp) revert Errors.InvalidProtectionEndTime();
        _validateProtectionScalars(
            numberOfTranches, ltvProtectClaims, ltvProtectForeclosure, openingFeeRate, cancellationFeeRate
        );
        if (trancheOneAmountFractionInMillionth > MILLION) revert Errors.FractionExceedsUnityInMillionth();
        if (trancheOneFeeRateInMillionth > MILLION) revert Errors.FractionExceedsUnityInMillionth();
        if (trancheTwoAmountFractionInMillionth > MILLION) revert Errors.FractionExceedsUnityInMillionth();
        if (trancheTwoFeeRateInMillionth > MILLION) revert Errors.FractionExceedsUnityInMillionth();
        if (trancheThreeAmountFractionInMillionth > MILLION) revert Errors.FractionExceedsUnityInMillionth();
        if (trancheThreeFeeRateInMillionth > MILLION) revert Errors.FractionExceedsUnityInMillionth();
    }

    ///@notice Validate some scalar values of the protection data
    ///@param numberOfTranches The number of tranches (uint8)
    ///@param ltvProtectClaims The LTV protection for claims in basis points (uint256)
    ///@param ltvProtectForeclosure The LTV protection for foreclosure in basis points (uint256)
    ///@param openingFeeRate The opening fee in base units (uint256)
    ///@param cancellationFeeRate The cancellation fee in base units (uint256)
    function _validateProtectionScalars(
        uint8 numberOfTranches,
        uint32 ltvProtectClaims,
        uint32 ltvProtectForeclosure,
        uint32 openingFeeRate,
        uint32 cancellationFeeRate
    ) private pure {
        if (numberOfTranches > 3) revert Errors.NumberOfProtectionClaimsTooHigh();
        if (ltvProtectClaims > MILLION) revert Errors.FractionExceedsUnityInMillionth();
        if (ltvProtectForeclosure > MILLION) revert Errors.FractionExceedsUnityInMillionth();
        if (openingFeeRate > MILLION) revert Errors.FractionExceedsUnityInMillionth();
        if (cancellationFeeRate > MILLION) revert Errors.FractionExceedsUnityInMillionth();
    }

    ///@notice Decode the protection data and convert the fractional values to absolute values
    ///@param encoding The encoded protection data
    ///@param promisedAmountInToken The promised amount in base units
    ///@return endTime The end time of the protection (in timestamp seconds uint40)
    ///@return numberOfTranches The number of tranches (uint8)
    ///@return ltvProtectForClaimsInBP The LTV protection for claims in basis points (uint256)
    ///@return ltvProtectForForeclosureInBP The LTV protection for foreclosure in basis points (uint256)
    ///@return openingFeeInToken The opening fee in base units (uint256)
    ///@return cancellationFeeInToken The cancellation fee in base units (uint256)
    ///@return trancheOneAmountInToken The amount of the first tranche in base units (uint256)
    ///@return trancheOneFeeInToken The fee of the first tranche in base units (uint256)
    ///@return trancheTwoAmountInToken The amount of the second tranche in base units (uint256)
    ///@return trancheTwoFeeInToken The fee of the second tranche in base units (uint256)
    ///@return trancheThreeAmountInToken The amount of the third tranche in base units (uint256)
    ///@return trancheThreeFeeInToken The fee of the third tranche in base units (uint256)
    function decodeProtectionDataToAbsoluteValues(uint256 encoding, uint256 promisedAmountInToken)
        internal
        pure
        returns (
            uint40,
            uint8,
            uint8,
            uint8,
            uint8,
            uint8,
            uint256,
            uint256,
            uint256,
            uint256,
            uint256,
            uint256,
            uint256,
            uint256,
            uint256,
            uint256
        )
    {
        (
            uint40 endTime,
            uint8 numberOfTranches,
            uint8 rightsEncoding,
            uint32 ltvProtectForClaimsInMillionth,
            uint32 ltvProtectForForeclosureInMillionth,
            uint32 openingFeeRateInMillionth,
            uint32 cancellationFeeRateInMillionth,
            uint32 trancheOneAmountFractionInMillionth,
            uint32 trancheOneFeeRateInMillionth,
            uint32 trancheTwoAmountFractionInMillionth,
            uint32 trancheTwoFeeRateInMillionth,
            uint32 trancheThreeAmountFractionInMillionth,
            uint32 trancheThreeFeeRateInMillionth
        ) = decodeProtectionData(encoding);

        return (
            endTime,
            numberOfTranches,
            _getProtocolRightsFromEncodedRights(rightsEncoding),
            _getRemoteProxyRightsFromEncodedRights(rightsEncoding),
            _getRemoteConcreteerRightsFromEncodedRights(rightsEncoding),
            _getRemotePublicRightsFromEncodedRights(rightsEncoding),
            uint256(ltvProtectForClaimsInMillionth).mulDiv(BP, MILLION),
            uint256(ltvProtectForForeclosureInMillionth).mulDiv(BP, MILLION),
            uint256(openingFeeRateInMillionth).mulDiv(promisedAmountInToken, MILLION),
            uint256(cancellationFeeRateInMillionth).mulDiv(promisedAmountInToken, MILLION),
            uint256(trancheOneAmountFractionInMillionth).mulDiv(promisedAmountInToken, MILLION),
            uint256(trancheOneFeeRateInMillionth).mulDiv(promisedAmountInToken, MILLION),
            uint256(trancheTwoAmountFractionInMillionth).mulDiv(promisedAmountInToken, MILLION),
            uint256(trancheTwoFeeRateInMillionth).mulDiv(promisedAmountInToken, MILLION),
            uint256(trancheThreeAmountFractionInMillionth).mulDiv(promisedAmountInToken, MILLION),
            uint256(trancheThreeFeeRateInMillionth).mulDiv(promisedAmountInToken, MILLION)
        );
    }

    ///@notice Updates the protection data by replacing the LTV protect threshold with a buffer value. (Not currently used, because we pass in the actual buffer value).
    ///@param encodedProtection The encoded protection data
    ///@param lenderLiqLtvInWad The LTV of the lender's liquidation threshold in Wad
    ///@param fallbackBuffer The fallback buffer value in Wad
    ///@return newEncodedProtection The updated encoded protection data
    ///@dev The buffer is a value between 0 and 1. And it is measured in WAD.
    function castLtvProtectIntoBuffer(uint256 encodedProtection, uint256 lenderLiqLtvInWad, uint256 fallbackBuffer)
        internal
        pure
        returns (uint256 newEncodedProtection)
    {
        uint256 ltvProtectClaimsInWad = getLtvProtectBufferForClaimsInWad(encodedProtection);
        uint256 ltvProtectForeclosureInWad = getLtvProtectBufferForForeclosureInWad(encodedProtection);
        uint256 ltvProtectBufferForClaims;
        uint256 ltvProtectBufferForForeclosure;
        if (ltvProtectClaimsInWad > lenderLiqLtvInWad) {
            ltvProtectBufferForClaims = fallbackBuffer;
        } else {
            ltvProtectBufferForClaims = WAD - ltvProtectClaimsInWad.mulDiv(WAD, lenderLiqLtvInWad);
        }
        if (ltvProtectForeclosureInWad > lenderLiqLtvInWad) {
            ltvProtectBufferForForeclosure = fallbackBuffer;
        } else {
            ltvProtectBufferForForeclosure = WAD - ltvProtectForeclosureInWad.mulDiv(WAD, lenderLiqLtvInWad);
        }
        newEncodedProtection = updateLtvProtectForClaims(encodedProtection, ltvProtectBufferForClaims);
        newEncodedProtection = updateLtvProtectForForeclosure(newEncodedProtection, ltvProtectBufferForForeclosure);
        return newEncodedProtection;
    }
}
