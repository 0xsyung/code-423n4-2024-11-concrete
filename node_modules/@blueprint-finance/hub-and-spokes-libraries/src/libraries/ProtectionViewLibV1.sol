// SPDX-License-Identifier: AGPL-3.0
pragma solidity 0.8.24;

import {Math} from "@openzeppelin/contracts/utils/math/Math.sol";
import {WAD} from "../utils/Constants.sol";
import {ProtectionLibV1} from "./ProtectionLibV1.sol";
import {CreditInfoV1} from "./CreditInfoV1.sol";
import {AmountType, ProtectionType} from "../utils/DataTypes.sol";
import {Errors} from "./Errors.sol";

library ProtectionViewLibV1 {
    using ProtectionLibV1 for uint256;
    using CreditInfoV1 for uint256;
    using Math for uint256;

    ///@notice Get the protection type of a protection
    ///@param protectionInfo The encoded protection info
    ///@param concreteLiteInfo The encoded concrete lite info
    ///@param creditInfo The encoded credit info
    ///@return protectionType protection type
    ///@dev There are 6 protection types:
    /// 1. Unprotected: The protection is not active
    /// 2. LiteProtected: The protection is active and is a lite protection
    /// 3. FullProtected: The protection is active and is a full protection
    /// 4. ExpiredWithDebt: The protection is expired and has debt
    /// 5. ExpiredWithoutDebtWithoutLite: The protection is expired and has no debt and is not lite protected
    /// 6. ExpiredWithoutDebtWithLite: The protection is expired and has no debt and is lite protected
    function getProtectionType(uint256 protectionInfo, uint256 concreteLiteInfo, uint256 creditInfo)
        internal
        view
        returns (ProtectionType protectionType)
    {
        bool notConcreteProtected = protectionInfo == 0;
        // number of claims is the slot which also keeps the boolen flag
        // whether concrete lite is enabled or not
        // For concrete lite the encoding slot that stores the number of claims in the protectionInfo is here used as a boolean to check if it is lite protected or not.
        bool notLiteProtected = !concreteLiteInfo.getConcreteLiteEnabled();
        if (notConcreteProtected) {
            if (notLiteProtected) {
                return ProtectionType.Unprotected;
            } else {
                return ProtectionType.LiteProtected;
            }
        } else {
            bool expired = block.timestamp > uint256(protectionInfo.getEndTime());
            if (!expired) {
                return ProtectionType.FullProtected;
            }
            uint256 debtInToken;
            (, debtInToken) = creditInfo.decodeCreditAmount();
            bool hasDebt = debtInToken > 0;
            if (hasDebt) {
                return ProtectionType.ExpiredWithDebt;
            } else {
                if (notLiteProtected) {
                    return ProtectionType.ExpiredWithoutDebtWithoutLite;
                } else {
                    return ProtectionType.ExpiredWithoutDebtWithLite;
                }
            }
        }
    }

    ///@notice Get the current intervention LTV of a protection
    ///@param protectionInfo The encoded protection info
    ///@param concreteLiteInfo The encoded concrete lite info
    ///@param creditInfo The encoded credit info
    ///@param lenderLiqLtvInWad The lender's liquidation LTV in WAD
    ///@return The current intervention LTV
    ///@dev The current intervention LTV is the LTV at which the protection will intervene
    /// If there is no intervention the function returns type(uint256).max
    function getCurrentInterventionLtv(
        uint256 protectionInfo,
        uint256 concreteLiteInfo,
        uint256 creditInfo,
        uint256 lenderLiqLtvInWad
    ) internal view returns (uint256) {
        bool notConcreteProtected = protectionInfo == 0;
        // number of claims is the slot which also keeps the boolen flag
        // whether concrete lite is enabled or not
        // Note: could rename that in the ProtectionLibV1 library
        bool notLiteProtected = concreteLiteInfo.getNumberOfClaims() == 0;
        uint256 bufferLtv;
        if (notConcreteProtected) {
            if (notLiteProtected) {
                return type(uint256).max;
            } else {
                bufferLtv = concreteLiteInfo.getLtvProtectBufferForForeclosureInWad();
                return lenderLiqLtvInWad.mulDiv(WAD - bufferLtv, WAD);
            }
        } else {
            bool expired = block.timestamp > uint256(protectionInfo.getEndTime());
            if (!expired) {
                bufferLtv = protectionInfo.getLtvProtectBufferForForeclosureInWad();
                return lenderLiqLtvInWad.mulDiv(WAD - bufferLtv, WAD);
            }
            uint256 debtInToken;
            (, debtInToken) = creditInfo.decodeCreditAmount();
            bool hasDebt = debtInToken > 0;
            if (hasDebt) {
                bufferLtv = protectionInfo.getLtvProtectBufferForForeclosureInWad();
                return lenderLiqLtvInWad.mulDiv(WAD - bufferLtv, WAD);
            } else {
                if (notLiteProtected) {
                    return type(uint256).max;
                } else {
                    bufferLtv = concreteLiteInfo.getLtvProtectBufferForForeclosureInWad();
                    return lenderLiqLtvInWad.mulDiv(WAD - bufferLtv, WAD);
                }
            }
        }
    }

    ///@notice Check if the critical Ltv gets surpassed after a borrow event
    ///@param criticalLtvInWad The critical LTV in WAD
    ///@param currentLtv The current LTV in WAD
    ///@param currentSupplyInCollateral The current supply in collateral tokens (e.g. if supply is 100 WETH, this is 100 * 1e18)
    ///@param borrowAmountInTokens The amount to borrow in tokens (e.g. if borrow amount is 2 USDC, this is 2 * 1e6)
    ///@param priceOfCollateralTokenInBorrowToken The price of the collateral token in borrow token (e.g. if 1 WETH-Wei in 1e-6 USDC), scaled by priceQuoteDenomination
    ///@param priceQuoteDenomination The price quote denomination is the denomination of the above quote.
    ///@return True if the critical LTV is surpassed after the borrow event, false otherwise
    function surpassCriticalLtvAfterBorrow(
        uint256 criticalLtvInWad,
        uint256 currentLtv,
        uint256 currentSupplyInCollateral,
        uint256 borrowAmountInTokens,
        uint256 priceOfCollateralTokenInBorrowToken,
        uint256 priceQuoteDenomination
    ) internal pure returns (bool) {
        // check
        // current + borrow/collateral * priceOfCollateralInBorrow > critical
        uint256 ltvAfterBorrow = currentLtv
            + borrowAmountInTokens.mulDiv(WAD, currentSupplyInCollateral).mulDiv(
                priceQuoteDenomination, priceOfCollateralTokenInBorrowToken
            );
        return ltvAfterBorrow > criticalLtvInWad;
    }

    ///@notice Check if the critical LTV is surpassed after a withdrawal
    ///@param criticalLtvInWad The critical LTV in WAD
    ///@param currentLtv The current LTV in WAD
    ///@param currentDebtInBorrowTokens The current debt in borrow tokens (e.g. if debt is 100 USDC, this is 100 * 1e6)
    ///@param withdrawAmountInTokens The amount to withdraw in tokens (e.g. if withdraw amount is 2 WETH, this is 2 * 1e18)
    ///@param priceOfCollateralTokenInBorrowToken The price of the collateral token in borrow token (e.g. if 1 WETH-Wei in 1e-6 USDC), scaled by priceQuoteDenomination
    ///@param priceQuoteDenomination The price quote denomination is the denomination of the above quote.
    function surpassCriticalLtvAfterWithdraw(
        uint256 criticalLtvInWad,
        uint256 currentLtv,
        uint256 currentDebtInBorrowTokens,
        uint256 withdrawAmountInTokens,
        uint256 priceOfCollateralTokenInBorrowToken,
        uint256 priceQuoteDenomination
    ) internal pure returns (bool) {
        // check
        // 1/crit + withdraw/collateral * priceOfCollateralInBorrow > 1/current
        uint256 criticalOverCurrentInWad = criticalLtvInWad.mulDiv(WAD, currentLtv);
        return (
            WAD
                + withdrawAmountInTokens.mulDiv(WAD, currentDebtInBorrowTokens).mulDiv(
                    priceOfCollateralTokenInBorrowToken, priceQuoteDenomination
                )
        ) > criticalOverCurrentInWad;
    }

    function checkForeclosureFeeAmount(
        uint256 providedFeeFractionInWad,
        uint256 feeFractionInWad,
        uint256 wiggleFactorInWad
    ) internal pure {
        bool tooHigh = providedFeeFractionInWad > feeFractionInWad.mulDiv(WAD + wiggleFactorInWad, WAD);
        bool tooLow = providedFeeFractionInWad < feeFractionInWad.mulDiv(WAD - wiggleFactorInWad, WAD);
        if (tooHigh || tooLow) {
            revert Errors.AmountDiviatesTooMuch(providedFeeFractionInWad, feeFractionInWad, wiggleFactorInWad);
        }
    }

    function checkAmountsFromInfo(
        uint256 amount,
        uint256 info,
        uint256 promisedAmountInToken,
        AmountType amountType,
        uint256 wiggleFactorInWad
    ) internal pure {
        uint256 expectedAmount;
        if (amountType == AmountType.ClaimFeeAmount || amountType == AmountType.ClaimAmount) {
            uint8 tranche = info.getNumberOfClaims() + 1;
            expectedAmount = (amountType == AmountType.ClaimFeeAmount)
                ? info.getTrancheFeeFractionInWad(tranche).mulDiv(promisedAmountInToken, WAD)
                : info.getTrancheAmountFractionInWad(tranche).mulDiv(promisedAmountInToken, WAD);
        } else if (amountType == AmountType.OpenProtectionFeeAmount) {
            expectedAmount = info.getOpeningFeeFractionInWad().mulDiv(promisedAmountInToken, WAD);
        } else if (amountType == AmountType.CancelProtectionFeeAmount) {
            expectedAmount = info.getCancellationFeeFractionInWad().mulDiv(promisedAmountInToken, WAD);
        } else {
            revert Errors.InvalidAmountType(uint8(amountType));
        }
        bool tooHigh = amount > expectedAmount.mulDiv(WAD + wiggleFactorInWad, WAD);
        bool tooLow = amount < expectedAmount.mulDiv(WAD - wiggleFactorInWad, WAD);
        if (tooHigh || tooLow) {
            revert Errors.AmountDiviatesTooMuch(amount, expectedAmount, wiggleFactorInWad);
        }
    }
}
